# VibeX CLI - Architectural Standards (Based on Gemini CLI)

## 🏗️ CORE ARCHITECTURAL PRINCIPLES

### Single Responsibility Principle
- Each file/component has ONE clear purpose
- Components MUST be under 200 lines
- Hooks MUST be under 100 lines and single-purpose
- Services handle one specific domain

### Comprehensive Testing
- EVERY module MUST have corresponding .test.ts/.test.tsx file
- Test coverage MUST be >90%
- Integration tests for complex flows (.integration.test.ts)
- Snapshot tests for UI components (__snapshots__)
- NO EXCEPTIONS TO TESTING REQUIREMENTS

### Logical Organization
- Clear package structure with proper separation
- Follow Gemini CLI directory patterns exactly
- Business logic in services, NOT in components/hooks
- UI components focus only on presentation

## 📁 FILE AND PACKAGE NAMING STANDARDS

### File Naming
- Components: PascalCase (InputPrompt.tsx, ThemeDialog.tsx)
- Services: camelCase (contextService.ts, gitService.ts)
- Utilities: kebab-case (file-utils.ts, error-handling.ts)
- Hooks: camelCase starting with 'use' (useAppState.ts)
- Types: kebab-case (app-types.ts, tool-types.ts)

### Package Naming
- Packages: lowercase with hyphens (code-assist, file-discovery)
- Directories: camelCase for features, lowercase for packages
- Core packages: core, tools, utils, services
- UI packages: components, hooks, types

### Directory Structure
```
src/
├── core/                 # Core business logic
├── services/            # Business services
│   ├── core/           # Core services
│   ├── tools/          # Tool services
│   └── utils/          # Utility services
├── ui/
│   ├── components/     # UI components
│   │   ├── messages/   # Message components
│   │   ├── shared/     # Shared components
│   │   └── dialogs/    # Dialog components
│   ├── hooks/          # UI hooks
│   └── types/          # UI types
├── tools/              # Tool implementations
└── utils/              # Utility functions
```

## 🎯 COMPONENT ARCHITECTURE RULES

### Component Requirements
- Components MUST be under 200 lines
- Business logic MUST be in services, not components
- Props interfaces named ComponentNameProps
- Every component needs .test.tsx file
- No complex state logic in components - use focused hooks
- Components organized in logical subdirectories

### Hook Requirements
- Hooks MUST be single-purpose and under 100 lines
- No business logic in hooks - delegate to services
- Every hook needs .test.ts file
- Hook composition over complex hooks
- Clear, descriptive names starting with 'use'

### Service Layer Requirements
- ALL business logic MUST be in services
- Services organized by domain responsibility
- Each service has single responsibility
- Services export clean interfaces with typed methods
- Every service needs .test.ts file
- Services handle errors internally with proper logging
- No direct UI dependencies in services

## 🔧 TOOL SYSTEM ARCHITECTURE

### Tool Requirements
- Modular, focused, composable tools
- Each tool has single responsibility
- Tool registry for centralized management
- Standardized tool interfaces
- Comprehensive testing for all tools
- Error handling with proper logging

### Tool Organization
- Tools organized by functionality
- Clear tool registration system
- Tool scheduling and lifecycle management
- Proper tool result handling

## 🚨 ERROR HANDLING STANDARDS

### Error Management
- Robust error management throughout
- Services handle errors internally
- Proper error logging with context
- User-friendly error messages
- Error boundaries for UI components
- Retry mechanisms where appropriate

### Logging Standards
- Structured logging with proper levels
- Context-aware error messages
- Performance logging for optimization
- Debug information in development

## ⚡ PERFORMANCE REQUIREMENTS

### React Performance
- Efficient patterns that avoid common React pitfalls
- Proper memoization where needed
- Avoid unnecessary re-renders
- Optimize component composition
- Lazy loading for large components

### General Performance
- Efficient data structures
- Proper async/await usage
- Memory management best practices
- Optimized file operations

## 📝 CODE QUALITY STANDARDS

### TypeScript Requirements
- Strict TypeScript configuration
- Proper type definitions for all interfaces
- No 'any' types except where absolutely necessary
- Generic types where appropriate
- Proper error type definitions

### Code Style
- Consistent formatting with Prettier
- ESLint rules enforced
- Clear, descriptive variable names
- Proper commenting for complex logic
- JSDoc for public APIs

## 🧪 TESTING STANDARDS

### Testing Requirements
- EVERY file MUST have corresponding test file
- Test coverage MUST be >90%
- Unit tests for all functions/methods
- Integration tests for complex workflows
- Snapshot tests for UI components
- Mock external dependencies properly
- Test error conditions and edge cases

### Test Organization
- Tests organized parallel to source structure
- Descriptive test names
- Proper describe/it block organization
- Setup and teardown where needed
- Test utilities for common patterns

## 🚫 ANTI-PATTERNS TO AVOID

### Component Anti-Patterns
- Monolithic components (>200 lines)
- Business logic in components
- Complex state management in components
- Mixing UI and business concerns
- Poor component composition

### Hook Anti-Patterns
- Complex, multi-purpose hooks
- Business logic in hooks
- Hooks without proper dependencies
- Overuse of useEffect
- Poor hook composition

### Service Anti-Patterns
- UI dependencies in services
- Monolithic services
- Poor error handling
- Lack of proper interfaces
- Missing tests

### General Anti-Patterns
- Poor naming conventions
- Lack of proper organization
- Missing tests
- Poor error handling
- Performance bottlenecks

## ✅ ENFORCEMENT

These rules are MANDATORY and will be enforced in all code reviews and development. 
Follow Gemini CLI patterns exactly - they represent best practices for CLI architecture.
NO EXCEPTIONS to these standards. 