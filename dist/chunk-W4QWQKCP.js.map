{"version":3,"sources":["../src/fs/operations.ts","../src/utils/validation.ts"],"sourcesContent":["/**\n * File Operations\n * \n * Functions for interacting with the file system in a safe and consistent way.\n * Includes utilities for reading, writing, searching, and analyzing files.\n */\n\nimport fs from 'fs/promises';\nimport { Stats } from 'fs';\nimport path from 'path';\nimport { createReadStream, createWriteStream } from 'fs';\nimport { pipeline } from 'stream/promises';\nimport { constants } from 'fs';\nimport { createUserError } from '../errors/formatter.js';\nimport { ErrorCategory } from '../errors/types.js';\nimport { logger } from '../utils/logger.js';\nimport { isValidPath, isValidFilePath, isValidDirectoryPath } from '../utils/validation.js';\n\n/**\n * Check if a file exists\n */\nexport async function fileExists(filePath: string): Promise<boolean> {\n  try {\n    const stats = await fs.stat(filePath);\n    return stats.isFile();\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Check if a directory exists\n */\nexport async function directoryExists(dirPath: string): Promise<boolean> {\n  try {\n    const stats = await fs.stat(dirPath);\n    return stats.isDirectory();\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Create a directory if it doesn't exist\n */\nexport async function ensureDirectory(dirPath: string): Promise<void> {\n  try {\n    if (!await directoryExists(dirPath)) {\n      await fs.mkdir(dirPath, { recursive: true });\n      logger.debug(`Created directory: ${dirPath}`);\n    }\n  } catch (error) {\n    logger.error(`Failed to create directory: ${dirPath}`, error);\n    throw createUserError(`Failed to create directory: ${dirPath}`, {\n      cause: error,\n      category: ErrorCategory.FILE_SYSTEM,\n      resolution: 'Check file permissions and try again.'\n    });\n  }\n}\n\n/**\n * Read a file as text\n */\nexport async function readTextFile(filePath: string, encoding: BufferEncoding = 'utf-8'): Promise<string> {\n  if (!isValidFilePath(filePath)) {\n    throw createUserError(`Invalid file path: ${filePath}`, {\n      category: ErrorCategory.VALIDATION,\n      resolution: 'Provide a valid file path.'\n    });\n  }\n\n  try {\n    if (!await fileExists(filePath)) {\n      throw createUserError(`File not found: ${filePath}`, {\n        category: ErrorCategory.FILE_NOT_FOUND,\n        resolution: 'Check the file path and try again.'\n      });\n    }\n\n    return await fs.readFile(filePath, { encoding });\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      throw createUserError(`File not found: ${filePath}`, {\n        cause: error,\n        category: ErrorCategory.FILE_NOT_FOUND,\n        resolution: 'Check the file path and try again.'\n      });\n    }\n\n    throw createUserError(`Failed to read file: ${filePath}`, {\n      cause: error,\n      category: ErrorCategory.FILE_READ,\n      resolution: 'Check file permissions and try again.'\n    });\n  }\n}\n\n/**\n * Read specific lines from a file\n */\nexport async function readFileLines(\n  filePath: string,\n  start: number,\n  end: number,\n  encoding: BufferEncoding = 'utf-8'\n): Promise<string[]> {\n  try {\n    const content = await readTextFile(filePath, encoding);\n    const lines = content.split('\\n');\n    \n    // Convert from 1-indexed to 0-indexed\n    const startIndex = Math.max(0, start - 1);\n    const endIndex = Math.min(lines.length, end);\n    \n    return lines.slice(startIndex, endIndex);\n  } catch (error) {\n    throw createUserError(`Failed to read lines ${start}-${end} from file: ${filePath}`, {\n      cause: error,\n      category: ErrorCategory.FILE_READ,\n      resolution: 'Check the file path and line range, then try again.'\n    });\n  }\n}\n\n/**\n * Write text to a file\n */\nexport async function writeTextFile(\n  filePath: string,\n  content: string,\n  options: { encoding?: BufferEncoding; createDir?: boolean; overwrite?: boolean } = {}\n): Promise<void> {\n  const { encoding = 'utf-8', createDir = true, overwrite = true } = options;\n  \n  if (!isValidFilePath(filePath)) {\n    throw createUserError(`Invalid file path: ${filePath}`, {\n      category: ErrorCategory.VALIDATION,\n      resolution: 'Provide a valid file path.'\n    });\n  }\n  \n  try {\n    // Ensure directory exists if createDir is true\n    if (createDir) {\n      const dirPath = path.dirname(filePath);\n      await ensureDirectory(dirPath);\n    }\n    \n    // Check if file exists and overwrite is false\n    const exists = await fileExists(filePath);\n    if (exists && !overwrite) {\n      throw createUserError(`File already exists: ${filePath}`, {\n        category: ErrorCategory.FILE_SYSTEM,\n        resolution: 'Use overwrite option to replace existing file.'\n      });\n    }\n    \n    // Write the file\n    await fs.writeFile(filePath, content, { encoding });\n    logger.debug(`Wrote ${content.length} bytes to: ${filePath}`);\n  } catch (error) {\n    if ((error as any).category) {\n      throw error; // Re-throw user errors\n    }\n    \n    throw createUserError(`Failed to write file: ${filePath}`, {\n      cause: error,\n      category: ErrorCategory.FILE_WRITE,\n      resolution: 'Check file permissions and try again.'\n    });\n  }\n}\n\n/**\n * Append text to a file\n */\nexport async function appendTextFile(\n  filePath: string,\n  content: string,\n  options: { encoding?: BufferEncoding; createDir?: boolean } = {}\n): Promise<void> {\n  const { encoding = 'utf-8', createDir = true } = options;\n  \n  if (!isValidFilePath(filePath)) {\n    throw createUserError(`Invalid file path: ${filePath}`, {\n      category: ErrorCategory.VALIDATION,\n      resolution: 'Provide a valid file path.'\n    });\n  }\n  \n  try {\n    // Ensure directory exists if createDir is true\n    if (createDir) {\n      const dirPath = path.dirname(filePath);\n      await ensureDirectory(dirPath);\n    }\n    \n    // Append to the file\n    await fs.appendFile(filePath, content, { encoding });\n    logger.debug(`Appended ${content.length} bytes to: ${filePath}`);\n  } catch (error) {\n    throw createUserError(`Failed to append to file: ${filePath}`, {\n      cause: error,\n      category: ErrorCategory.FILE_WRITE,\n      resolution: 'Check file permissions and try again.'\n    });\n  }\n}\n\n/**\n * Delete a file\n */\nexport async function deleteFile(filePath: string): Promise<void> {\n  if (!isValidFilePath(filePath)) {\n    throw createUserError(`Invalid file path: ${filePath}`, {\n      category: ErrorCategory.VALIDATION,\n      resolution: 'Provide a valid file path.'\n    });\n  }\n  \n  try {\n    const exists = await fileExists(filePath);\n    if (!exists) {\n      logger.debug(`File does not exist, nothing to delete: ${filePath}`);\n      return;\n    }\n    \n    await fs.unlink(filePath);\n    logger.debug(`Deleted file: ${filePath}`);\n  } catch (error) {\n    throw createUserError(`Failed to delete file: ${filePath}`, {\n      cause: error,\n      category: ErrorCategory.FILE_SYSTEM,\n      resolution: 'Check file permissions and try again.'\n    });\n  }\n}\n\n/**\n * Rename a file or directory\n */\nexport async function rename(oldPath: string, newPath: string): Promise<void> {\n  if (!isValidPath(oldPath) || !isValidPath(newPath)) {\n    throw createUserError(`Invalid path: ${!isValidPath(oldPath) ? oldPath : newPath}`, {\n      category: ErrorCategory.VALIDATION,\n      resolution: 'Provide valid file paths.'\n    });\n  }\n  \n  try {\n    const exists = await fileExists(oldPath) || await directoryExists(oldPath);\n    if (!exists) {\n      throw createUserError(`Path not found: ${oldPath}`, {\n        category: ErrorCategory.FILE_NOT_FOUND,\n        resolution: 'Check the source path and try again.'\n      });\n    }\n    \n    await fs.rename(oldPath, newPath);\n    logger.debug(`Renamed: ${oldPath} -> ${newPath}`);\n  } catch (error) {\n    if ((error as any).category) {\n      throw error; // Re-throw user errors\n    }\n    \n    throw createUserError(`Failed to rename: ${oldPath} -> ${newPath}`, {\n      cause: error,\n      category: ErrorCategory.FILE_SYSTEM,\n      resolution: 'Check file permissions and ensure destination path is valid.'\n    });\n  }\n}\n\n/**\n * Copy a file\n */\nexport async function copyFile(\n  sourcePath: string,\n  destPath: string,\n  options: { overwrite?: boolean; createDir?: boolean } = {}\n): Promise<void> {\n  const { overwrite = false, createDir = true } = options;\n  \n  if (!isValidFilePath(sourcePath) || !isValidFilePath(destPath)) {\n    throw createUserError(`Invalid file path: ${!isValidFilePath(sourcePath) ? sourcePath : destPath}`, {\n      category: ErrorCategory.VALIDATION,\n      resolution: 'Provide valid file paths.'\n    });\n  }\n  \n  try {\n    // Check if source exists\n    if (!await fileExists(sourcePath)) {\n      throw createUserError(`Source file not found: ${sourcePath}`, {\n        category: ErrorCategory.FILE_NOT_FOUND,\n        resolution: 'Check the source path and try again.'\n      });\n    }\n    \n    // Ensure directory exists if createDir is true\n    if (createDir) {\n      const dirPath = path.dirname(destPath);\n      await ensureDirectory(dirPath);\n    }\n    \n    // Set copy flags\n    const flags = overwrite ? 0 : constants.COPYFILE_EXCL;\n    \n    await fs.copyFile(sourcePath, destPath, flags);\n    logger.debug(`Copied file: ${sourcePath} -> ${destPath}`);\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'EEXIST' && !overwrite) {\n      throw createUserError(`Destination file already exists: ${destPath}`, {\n        cause: error,\n        category: ErrorCategory.FILE_SYSTEM,\n        resolution: 'Use overwrite option to replace existing file.'\n      });\n    }\n    \n    if ((error as any).category) {\n      throw error; // Re-throw user errors\n    }\n    \n    throw createUserError(`Failed to copy file: ${sourcePath} -> ${destPath}`, {\n      cause: error,\n      category: ErrorCategory.FILE_SYSTEM,\n      resolution: 'Check file permissions and paths, then try again.'\n    });\n  }\n}\n\n/**\n * List files and directories in a directory\n */\nexport async function listDirectory(dirPath: string): Promise<string[]> {\n  if (!isValidDirectoryPath(dirPath)) {\n    throw createUserError(`Invalid directory path: ${dirPath}`, {\n      category: ErrorCategory.VALIDATION,\n      resolution: 'Provide a valid directory path.'\n    });\n  }\n  \n  try {\n    if (!await directoryExists(dirPath)) {\n      throw createUserError(`Directory not found: ${dirPath}`, {\n        category: ErrorCategory.FILE_NOT_FOUND,\n        resolution: 'Check the directory path and try again.'\n      });\n    }\n    \n    return await fs.readdir(dirPath);\n  } catch (error) {\n    if ((error as any).category) {\n      throw error; // Re-throw user errors\n    }\n    \n    throw createUserError(`Failed to list directory: ${dirPath}`, {\n      cause: error,\n      category: ErrorCategory.FILE_SYSTEM,\n      resolution: 'Check directory permissions and try again.'\n    });\n  }\n}\n\n/**\n * Get file or directory information\n */\nexport async function getFileInfo(filePath: string): Promise<Stats> {\n  if (!isValidPath(filePath)) {\n    throw createUserError(`Invalid path: ${filePath}`, {\n      category: ErrorCategory.VALIDATION,\n      resolution: 'Provide a valid file or directory path.'\n    });\n  }\n  \n  try {\n    return await fs.stat(filePath);\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      throw createUserError(`Path not found: ${filePath}`, {\n        cause: error,\n        category: ErrorCategory.FILE_NOT_FOUND,\n        resolution: 'Check the path and try again.'\n      });\n    }\n    \n    throw createUserError(`Failed to get file info: ${filePath}`, {\n      cause: error,\n      category: ErrorCategory.FILE_SYSTEM,\n      resolution: 'Check permissions and try again.'\n    });\n  }\n}\n\n/**\n * Find files matching a pattern\n */\nexport async function findFiles(\n  directory: string,\n  options: { pattern?: RegExp; recursive?: boolean; includeDirectories?: boolean } = {}\n): Promise<string[]> {\n  const { pattern, recursive = true, includeDirectories = false } = options;\n  \n  if (!isValidDirectoryPath(directory)) {\n    throw createUserError(`Invalid directory path: ${directory}`, {\n      category: ErrorCategory.VALIDATION,\n      resolution: 'Provide a valid directory path.'\n    });\n  }\n  \n  try {\n    if (!await directoryExists(directory)) {\n      throw createUserError(`Directory not found: ${directory}`, {\n        category: ErrorCategory.FILE_NOT_FOUND,\n        resolution: 'Check the directory path and try again.'\n      });\n    }\n    \n    const results: string[] = [];\n    \n    // Helper function to traverse the directory\n    async function traverseDirectory(dir: string): Promise<void> {\n      const entries = await fs.readdir(dir, { withFileTypes: true });\n      \n      for (const entry of entries) {\n        const fullPath = path.join(dir, entry.name);\n        \n        if (entry.isDirectory()) {\n          if (includeDirectories && (!pattern || pattern.test(entry.name))) {\n            results.push(fullPath);\n          }\n          \n          if (recursive) {\n            await traverseDirectory(fullPath);\n          }\n        } else if (entry.isFile()) {\n          if (!pattern || pattern.test(entry.name)) {\n            results.push(fullPath);\n          }\n        }\n      }\n    }\n    \n    await traverseDirectory(directory);\n    return results;\n  } catch (error) {\n    if ((error as any).category) {\n      throw error; // Re-throw user errors\n    }\n    \n    throw createUserError(`Failed to find files in directory: ${directory}`, {\n      cause: error,\n      category: ErrorCategory.FILE_SYSTEM,\n      resolution: 'Check directory permissions and try again.'\n    });\n  }\n}\n\n/**\n * Stream a file to another location\n */\nexport async function streamFile(\n  sourcePath: string,\n  destPath: string,\n  options: { overwrite?: boolean; createDir?: boolean } = {}\n): Promise<void> {\n  const { overwrite = false, createDir = true } = options;\n  \n  if (!isValidFilePath(sourcePath) || !isValidFilePath(destPath)) {\n    throw createUserError(`Invalid file path: ${!isValidFilePath(sourcePath) ? sourcePath : destPath}`, {\n      category: ErrorCategory.VALIDATION,\n      resolution: 'Provide valid file paths.'\n    });\n  }\n  \n  try {\n    // Check if source exists\n    if (!await fileExists(sourcePath)) {\n      throw createUserError(`Source file not found: ${sourcePath}`, {\n        category: ErrorCategory.FILE_NOT_FOUND,\n        resolution: 'Check the source path and try again.'\n      });\n    }\n    \n    // Check if destination exists and overwrite is false\n    if (!overwrite && await fileExists(destPath)) {\n      throw createUserError(`Destination file already exists: ${destPath}`, {\n        category: ErrorCategory.FILE_SYSTEM,\n        resolution: 'Use overwrite option to replace existing file.'\n      });\n    }\n    \n    // Ensure directory exists if createDir is true\n    if (createDir) {\n      const dirPath = path.dirname(destPath);\n      await ensureDirectory(dirPath);\n    }\n    \n    const source = createReadStream(sourcePath);\n    const destination = createWriteStream(destPath);\n    \n    await pipeline(source, destination);\n    logger.debug(`Streamed file: ${sourcePath} -> ${destPath}`);\n  } catch (error) {\n    if ((error as any).category) {\n      throw error; // Re-throw user errors\n    }\n    \n    throw createUserError(`Failed to stream file: ${sourcePath} -> ${destPath}`, {\n      cause: error,\n      category: ErrorCategory.FILE_SYSTEM,\n      resolution: 'Check file permissions and paths, then try again.'\n    });\n  }\n}\n\n/**\n * Create a temporary file\n */\nexport async function createTempFile(\n  options: { prefix?: string; suffix?: string; content?: string } = {}\n): Promise<string> {\n  const { prefix = 'tmp-', suffix = '', content = '' } = options;\n  \n  try {\n    // Create a temporary filename\n    const tempDir = await fs.mkdtemp(path.join(path.resolve(process.env.TEMP || process.env.TMP || '/tmp'), prefix));\n    const tempFileName = `${prefix}${Date.now()}${suffix}`;\n    const tempFilePath = path.join(tempDir, tempFileName);\n    \n    // Write content if provided\n    if (content) {\n      await fs.writeFile(tempFilePath, content);\n    } else {\n      await fs.writeFile(tempFilePath, '');\n    }\n    \n    logger.debug(`Created temporary file: ${tempFilePath}`);\n    return tempFilePath;\n  } catch (error) {\n    throw createUserError('Failed to create temporary file', {\n      cause: error,\n      category: ErrorCategory.FILE_SYSTEM,\n      resolution: 'Check temporary directory permissions and try again.'\n    });\n  }\n} ","/**\n * Validation Utilities\n * \n * Provides utilities for validating inputs, checking types,\n * and ensuring data conforms to expected formats.\n */\n\n/**\n * Check if a value is defined (not undefined or null)\n */\nexport function isDefined<T>(value: T | undefined | null): value is T {\n  return value !== undefined && value !== null;\n}\n\n/**\n * Check if a value is a non-empty string\n */\nexport function isNonEmptyString(value: unknown): value is string {\n  return typeof value === 'string' && value.trim().length > 0;\n}\n\n/**\n * Check if a value is a number (and optionally within range)\n */\nexport function isNumber(value: unknown, options: { min?: number; max?: number } = {}): value is number {\n  if (typeof value !== 'number' || isNaN(value)) {\n    return false;\n  }\n  \n  const { min, max } = options;\n  \n  if (min !== undefined && value < min) {\n    return false;\n  }\n  \n  if (max !== undefined && value > max) {\n    return false;\n  }\n  \n  return true;\n}\n\n/**\n * Check if a value is a boolean\n */\nexport function isBoolean(value: unknown): value is boolean {\n  return typeof value === 'boolean';\n}\n\n/**\n * Check if a value is an object (and not an array or null)\n */\nexport function isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\n/**\n * Check if a value is an array\n */\nexport function isArray<T>(value: unknown, itemValidator?: (item: unknown) => item is T): value is T[] {\n  if (!Array.isArray(value)) {\n    return false;\n  }\n  \n  if (itemValidator) {\n    return value.every(item => itemValidator(item));\n  }\n  \n  return true;\n}\n\n/**\n * Check if a value is a valid date\n */\nexport function isValidDate(value: unknown): value is Date {\n  return value instanceof Date && !isNaN(value.getTime());\n}\n\n/**\n * Check if a string is a valid email address\n */\nexport function isEmail(value: string): boolean {\n  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n  return emailRegex.test(value);\n}\n\n/**\n * Check if a string is a valid URL\n */\nexport function isUrl(value: string): boolean {\n  try {\n    const url = new URL(value);\n    return url.protocol === 'http:' || url.protocol === 'https:';\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Check if a string is a valid path\n */\nexport function isValidPath(value: string): boolean {\n  // Basic path validation\n  return /^[a-zA-Z0-9\\/\\\\\\._\\-~]+$/.test(value) && !value.includes('..') && value.length > 0;\n}\n\n/**\n * Check if a string is a valid file path\n */\nexport function isValidFilePath(value: string): boolean {\n  return isValidPath(value) && !value.endsWith('/') && !value.endsWith('\\\\');\n}\n\n/**\n * Check if a string is a valid directory path\n */\nexport function isValidDirectoryPath(value: string): boolean {\n  return isValidPath(value);\n}\n\n/**\n * Check if a string is valid JSON\n */\nexport function isValidJson(value: string): boolean {\n  try {\n    JSON.parse(value);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Validate an object against a schema\n */\nexport function validateObject<T>(\n  obj: unknown,\n  schema: Record<keyof T, (value: unknown) => boolean>,\n  options: { allowExtraProps?: boolean; required?: Array<keyof T> } = {}\n): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n  \n  if (!isObject(obj)) {\n    return { valid: false, errors: ['Expected an object'] };\n  }\n  \n  // Check required fields\n  if (options.required) {\n    for (const key of options.required) {\n      if (!(key in obj)) {\n        errors.push(`Missing required field: ${String(key)}`);\n      }\n    }\n  }\n  \n  // Check each field against schema\n  for (const [key, validator] of Object.entries(schema) as Array<[string, (value: unknown) => boolean]>) {\n    if (key in obj) {\n      const value = obj[key as keyof typeof obj];\n      if (!validator(value)) {\n        errors.push(`Invalid value for field: ${key}`);\n      }\n    }\n  }\n  \n  // Check for extra properties\n  if (options.allowExtraProps === false) {\n    for (const key of Object.keys(obj)) {\n      if (!(key in schema)) {\n        errors.push(`Unexpected field: ${key}`);\n      }\n    }\n  }\n  \n  return {\n    valid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Create a validator function for an enum\n */\nexport function createEnumValidator<T extends string | number>(enumObj: Record<string, T>) {\n  const validValues = Object.values(enumObj);\n  \n  return function isValidEnum(value: unknown): value is T {\n    return validValues.includes(value as T);\n  };\n}\n\n/**\n * Create a validator that ensures a value is one of the allowed values\n */\nexport function createOneOfValidator<T>(allowedValues: T[]) {\n  return function isOneOf(value: unknown): value is T {\n    return allowedValues.includes(value as T);\n  };\n}\n\n/**\n * Create a validator that combines multiple validators with AND logic\n */\nexport function createAllValidator(...validators: Array<(value: unknown) => boolean>) {\n  return function validateAll(value: unknown): boolean {\n    return validators.every(validator => validator(value));\n  };\n}\n\n/**\n * Create a validator that combines multiple validators with OR logic\n */\nexport function createAnyValidator(...validators: Array<(value: unknown) => boolean>) {\n  return function validateAny(value: unknown): boolean {\n    return validators.some(validator => validator(value));\n  };\n}\n\nexport default {\n  isDefined,\n  isNonEmptyString,\n  isNumber,\n  isBoolean,\n  isObject,\n  isArray,\n  isValidDate,\n  isEmail,\n  isUrl,\n  isValidPath,\n  isValidFilePath,\n  isValidDirectoryPath,\n  isValidJson,\n  validateObject,\n  createEnumValidator,\n  createOneOfValidator,\n  createAllValidator,\n  createAnyValidator\n}; "],"mappings":"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","names":[]}