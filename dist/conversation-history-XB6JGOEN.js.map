{"version":3,"sources":["../src/utils/conversation-history.ts"],"sourcesContent":["/**\n * Conversation History Manager\n * \n * Manages persistent storage and retrieval of conversation history\n * between CLI sessions, providing continuity and context.\n */\n\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { logger } from './logger.js';\nimport { createUserError } from '../errors/formatter.js';\nimport { ErrorCategory } from '../errors/types.js';\n\n/**\n * Conversation message interface\n */\nexport interface ConversationMessage {\n  /**\n   * Unique message ID\n   */\n  id: string;\n  \n  /**\n   * Message timestamp\n   */\n  timestamp: number;\n  \n  /**\n   * Message role (user or assistant)\n   */\n  role: 'user' | 'assistant' | 'system';\n  \n  /**\n   * Message content\n   */\n  content: string;\n  \n  /**\n   * Optional metadata\n   */\n  metadata?: {\n    model?: string;\n    tokens?: {\n      input: number;\n      output: number;\n    };\n    command?: string;\n    file?: string;\n  };\n}\n\n/**\n * Conversation session interface\n */\nexport interface ConversationSession {\n  /**\n   * Session ID\n   */\n  id: string;\n  \n  /**\n   * Session start time\n   */\n  startTime: number;\n  \n  /**\n   * Session end time (if ended)\n   */\n  endTime?: number;\n  \n  /**\n   * Session title/description\n   */\n  title?: string;\n  \n  /**\n   * Messages in this session\n   */\n  messages: ConversationMessage[];\n  \n  /**\n   * Session statistics\n   */\n  stats?: {\n    messageCount: number;\n    totalTokens: number;\n    duration: number;\n  };\n}\n\n/**\n * History storage options\n */\nexport interface HistoryOptions {\n  /**\n   * Maximum number of sessions to keep\n   */\n  maxSessions?: number;\n  \n  /**\n   * Maximum age of sessions in days\n   */\n  maxAgeInDays?: number;\n  \n  /**\n   * Storage directory path\n   */\n  storageDir?: string;\n  \n  /**\n   * Enable compression for old sessions\n   */\n  enableCompression?: boolean;\n}\n\n/**\n * Conversation History Manager\n */\nexport class ConversationHistoryManager {\n  private storageDir: string;\n  private options: Required<HistoryOptions>;\n  private currentSession: ConversationSession | null = null;\n\n  constructor(options: HistoryOptions = {}) {\n    this.options = {\n      maxSessions: options.maxSessions || 100,\n      maxAgeInDays: options.maxAgeInDays || 30,\n      storageDir: options.storageDir || path.join(os.homedir(), '.claude-code', 'history'),\n      enableCompression: options.enableCompression || true\n    };\n    \n    this.storageDir = this.options.storageDir;\n  }\n\n  /**\n   * Initialize the history manager\n   */\n  async initialize(): Promise<void> {\n    try {\n      // Ensure storage directory exists\n      await fs.mkdir(this.storageDir, { recursive: true });\n      \n      // Clean up old sessions\n      await this.cleanupOldSessions();\n      \n      logger.debug('Conversation history manager initialized', {\n        storageDir: this.storageDir,\n        maxSessions: this.options.maxSessions\n      });\n    } catch (error) {\n      logger.error('Failed to initialize conversation history manager:', error);\n      throw createUserError('Failed to initialize conversation history', {\n        cause: error,\n        category: ErrorCategory.INITIALIZATION\n      });\n    }\n  }\n\n  /**\n   * Start a new conversation session\n   */\n  async startSession(title?: string): Promise<string> {\n    const sessionId = this.generateSessionId();\n    \n    this.currentSession = {\n      id: sessionId,\n      startTime: Date.now(),\n      title: title || `Session ${new Date().toLocaleString()}`,\n      messages: []\n    };\n    \n    logger.debug(`Started new conversation session: ${sessionId}`);\n    return sessionId;\n  }\n\n  /**\n   * End the current session\n   */\n  async endSession(): Promise<void> {\n    if (!this.currentSession) {\n      return;\n    }\n    \n    this.currentSession.endTime = Date.now();\n    this.currentSession.stats = this.calculateSessionStats(this.currentSession);\n    \n    // Save the session\n    await this.saveSession(this.currentSession);\n    \n    logger.debug(`Ended conversation session: ${this.currentSession.id}`);\n    this.currentSession = null;\n  }\n\n  /**\n   * Add a message to the current session\n   */\n  async addMessage(\n    role: 'user' | 'assistant' | 'system',\n    content: string,\n    metadata?: ConversationMessage['metadata']\n  ): Promise<string> {\n    if (!this.currentSession) {\n      await this.startSession();\n    }\n    \n    const messageId = this.generateMessageId();\n    const message: ConversationMessage = {\n      id: messageId,\n      timestamp: Date.now(),\n      role,\n      content,\n      metadata\n    };\n    \n    this.currentSession!.messages.push(message);\n    \n    // Auto-save every few messages to prevent data loss\n    if (this.currentSession!.messages.length % 5 === 0) {\n      await this.saveSession(this.currentSession!);\n    }\n    \n    return messageId;\n  }\n\n  /**\n   * Get the current session\n   */\n  getCurrentSession(): ConversationSession | null {\n    return this.currentSession;\n  }\n\n  /**\n   * Get recent messages from current session\n   */\n  getRecentMessages(count: number = 10): ConversationMessage[] {\n    if (!this.currentSession) {\n      return [];\n    }\n    \n    return this.currentSession.messages.slice(-count);\n  }\n\n  /**\n   * Search messages across all sessions\n   */\n  async searchMessages(query: string, limit: number = 50): Promise<ConversationMessage[]> {\n    const sessions = await this.listSessions();\n    const results: ConversationMessage[] = [];\n    \n    for (const sessionSummary of sessions) {\n      if (results.length >= limit) break;\n      \n      try {\n        const session = await this.loadSession(sessionSummary.id);\n        const matchingMessages = session.messages.filter(msg =>\n          msg.content.toLowerCase().includes(query.toLowerCase())\n        );\n        \n        results.push(...matchingMessages.slice(0, limit - results.length));\n      } catch (error) {\n        logger.warn(`Failed to search in session ${sessionSummary.id}:`, error);\n      }\n    }\n    \n    return results.slice(0, limit);\n  }\n\n  /**\n   * List all saved sessions\n   */\n  async listSessions(): Promise<Array<{\n    id: string;\n    title: string;\n    startTime: number;\n    endTime?: number;\n    messageCount: number;\n  }>> {\n    try {\n      const files = await fs.readdir(this.storageDir);\n      const sessionFiles = files.filter(f => f.endsWith('.json'));\n      \n      const sessions = await Promise.all(\n        sessionFiles.map(async (file) => {\n          try {\n            const sessionPath = path.join(this.storageDir, file);\n            const content = await fs.readFile(sessionPath, 'utf-8');\n            const session: ConversationSession = JSON.parse(content);\n            \n            return {\n              id: session.id,\n              title: session.title || 'Untitled Session',\n              startTime: session.startTime,\n              endTime: session.endTime,\n              messageCount: session.messages.length\n            };\n          } catch (error) {\n            logger.warn(`Failed to read session file ${file}:`, error);\n            return null;\n          }\n        })\n      );\n      \n      return sessions\n        .filter((s): s is NonNullable<typeof s> => s !== null)\n        .sort((a, b) => b.startTime - a.startTime);\n    } catch (error) {\n      logger.error('Failed to list sessions:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Load a specific session\n   */\n  async loadSession(sessionId: string): Promise<ConversationSession> {\n    const sessionPath = path.join(this.storageDir, `${sessionId}.json`);\n    \n    try {\n      const content = await fs.readFile(sessionPath, 'utf-8');\n      return JSON.parse(content);\n    } catch (error) {\n      throw createUserError(`Session not found: ${sessionId}`, {\n        cause: error,\n        category: ErrorCategory.FILE_NOT_FOUND\n      });\n    }\n  }\n\n  /**\n   * Delete a session\n   */\n  async deleteSession(sessionId: string): Promise<void> {\n    const sessionPath = path.join(this.storageDir, `${sessionId}.json`);\n    \n    try {\n      await fs.unlink(sessionPath);\n      logger.debug(`Deleted session: ${sessionId}`);\n    } catch (error) {\n      throw createUserError(`Failed to delete session: ${sessionId}`, {\n        cause: error,\n        category: ErrorCategory.FILE_SYSTEM\n      });\n    }\n  }\n\n  /**\n   * Export session to a file\n   */\n  async exportSession(sessionId: string, outputPath: string): Promise<void> {\n    const session = await this.loadSession(sessionId);\n    \n    // Create a readable export format\n    const exportData = {\n      session: {\n        id: session.id,\n        title: session.title,\n        startTime: new Date(session.startTime).toISOString(),\n        endTime: session.endTime ? new Date(session.endTime).toISOString() : null,\n        stats: session.stats\n      },\n      messages: session.messages.map(msg => ({\n        timestamp: new Date(msg.timestamp).toISOString(),\n        role: msg.role,\n        content: msg.content,\n        metadata: msg.metadata\n      }))\n    };\n    \n    await fs.writeFile(outputPath, JSON.stringify(exportData, null, 2));\n    logger.info(`Session exported to: ${outputPath}`);\n  }\n\n  /**\n   * Save a session to disk\n   */\n  private async saveSession(session: ConversationSession): Promise<void> {\n    const sessionPath = path.join(this.storageDir, `${session.id}.json`);\n    \n    try {\n      await fs.writeFile(sessionPath, JSON.stringify(session, null, 2));\n      logger.debug(`Saved session: ${session.id}`);\n    } catch (error) {\n      logger.error(`Failed to save session ${session.id}:`, error);\n    }\n  }\n\n  /**\n   * Clean up old sessions\n   */\n  private async cleanupOldSessions(): Promise<void> {\n    try {\n      const sessions = await this.listSessions();\n      const now = Date.now();\n      const maxAge = this.options.maxAgeInDays * 24 * 60 * 60 * 1000;\n      \n      // Delete sessions that are too old\n      const oldSessions = sessions.filter(s => \n        now - s.startTime > maxAge\n      );\n      \n      for (const session of oldSessions) {\n        await this.deleteSession(session.id);\n      }\n      \n      // Delete excess sessions (keep only the most recent)\n      const recentSessions = sessions\n        .filter(s => now - s.startTime <= maxAge)\n        .sort((a, b) => b.startTime - a.startTime);\n      \n      if (recentSessions.length > this.options.maxSessions) {\n        const excessSessions = recentSessions.slice(this.options.maxSessions);\n        for (const session of excessSessions) {\n          await this.deleteSession(session.id);\n        }\n      }\n      \n      if (oldSessions.length > 0 || recentSessions.length > this.options.maxSessions) {\n        logger.debug(`Cleaned up ${oldSessions.length} old sessions and ${Math.max(0, recentSessions.length - this.options.maxSessions)} excess sessions`);\n      }\n    } catch (error) {\n      logger.warn('Failed to cleanup old sessions:', error);\n    }\n  }\n\n  /**\n   * Calculate session statistics\n   */\n  private calculateSessionStats(session: ConversationSession): ConversationSession['stats'] {\n    const messageCount = session.messages.length;\n    const totalTokens = session.messages.reduce((sum, msg) => {\n      return sum + (msg.metadata?.tokens?.input || 0) + (msg.metadata?.tokens?.output || 0);\n    }, 0);\n    \n    const duration = session.endTime ? session.endTime - session.startTime : Date.now() - session.startTime;\n    \n    return {\n      messageCount,\n      totalTokens,\n      duration\n    };\n  }\n\n  /**\n   * Generate a unique session ID\n   */\n  private generateSessionId(): string {\n    const timestamp = Date.now().toString(36);\n    const random = Math.random().toString(36).substring(2, 8);\n    return `session_${timestamp}_${random}`;\n  }\n\n  /**\n   * Generate a unique message ID\n   */\n  private generateMessageId(): string {\n    const timestamp = Date.now().toString(36);\n    const random = Math.random().toString(36).substring(2, 8);\n    return `msg_${timestamp}_${random}`;\n  }\n}\n\n/**\n * Global conversation history manager instance\n */\nexport const conversationHistory = new ConversationHistoryManager(); "],"mappings":"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","names":[]}