{"version":3,"sources":["../src/terminal/index.ts","../src/terminal/formatting.ts","../src/terminal/prompt.ts","../src/auth/tokens.ts","../src/utils/async.ts","../../node_modules/open/index.js","../../node_modules/is-wsl/index.js","../../node_modules/is-inside-container/index.js","../../node_modules/is-docker/index.js","../../node_modules/define-lazy-prop/index.js","../../node_modules/default-browser/index.js","../../node_modules/default-browser-id/index.js","../../node_modules/run-applescript/index.js","../../node_modules/bundle-name/index.js","../../node_modules/default-browser/windows.js","../src/auth/oauth.ts","../src/auth/manager.ts","../src/auth/index.ts","../src/ai/unified-client.ts","../src/tools/ripgrep.ts","../src/ai/index.ts","../src/codebase/analyzer.ts","../src/codebase/index.ts","../src/commands/register.ts","../src/fileops/index.ts","../src/execution/index.ts","../src/tools/mcp-client.ts","../src/index.ts"],"sourcesContent":["/**\n * Terminal Interface Module\n * \n * Provides a user interface for interacting with Claude Code in the terminal.\n * Handles input/output, formatting, and display.\n */\n\nimport chalk from 'chalk';\nimport inquirer from 'inquirer';\nimport ora, { Ora } from 'ora';\nimport terminalLink from 'terminal-link';\nimport { table } from 'table';\nimport { logger } from '../utils/logger.js';\nimport { TerminalInterface, TerminalConfig, PromptOptions, SpinnerInstance } from './types.js';\nimport { formatOutput, clearScreen, getTerminalSize } from './formatting.js';\nimport { createPrompt } from './prompt.js';\n\n/**\n * Initialize the terminal interface\n */\nexport async function initTerminal(config: any): Promise<TerminalInterface> {\n  logger.debug('Initializing terminal interface');\n  \n  const terminalConfig: TerminalConfig = {\n    theme: config.terminal?.theme || 'system',\n    useColors: config.terminal?.useColors !== false,\n    showProgressIndicators: config.terminal?.showProgressIndicators !== false,\n    codeHighlighting: config.terminal?.codeHighlighting !== false,\n    maxHeight: config.terminal?.maxHeight,\n    maxWidth: config.terminal?.maxWidth,\n  };\n  \n  const terminal = new Terminal(terminalConfig);\n  \n  try {\n    // Detect terminal capabilities\n    await terminal.detectCapabilities();\n    \n    return terminal;\n  } catch (error) {\n    logger.warn('Error initializing terminal interface:', error);\n    \n    // Return a basic terminal interface even if there was an error\n    return terminal;\n  }\n}\n\n/**\n * Terminal class for handling user interaction\n */\nclass Terminal implements TerminalInterface {\n  private config: TerminalConfig;\n  private activeSpinners: Map<string, SpinnerInstance> = new Map();\n  private terminalWidth: number;\n  private terminalHeight: number;\n  private isInteractive: boolean;\n\n  constructor(config: TerminalConfig) {\n    this.config = config;\n    \n    // Get initial terminal size\n    const { rows, columns } = getTerminalSize();\n    this.terminalHeight = config.maxHeight || rows;\n    this.terminalWidth = config.maxWidth || columns;\n    \n    // Assume interactive by default\n    this.isInteractive = process.stdout.isTTY && process.stdin.isTTY;\n    \n    // Listen for terminal resize events\n    process.stdout.on('resize', () => {\n      const { rows, columns } = getTerminalSize();\n      this.terminalHeight = config.maxHeight || rows;\n      this.terminalWidth = config.maxWidth || columns;\n      logger.debug(`Terminal resized to ${columns}x${rows}`);\n    });\n  }\n\n  /**\n   * Detect terminal capabilities\n   */\n  async detectCapabilities(): Promise<void> {\n    // Check if the terminal is interactive\n    this.isInteractive = process.stdout.isTTY && process.stdin.isTTY;\n    \n    // Check color support\n    if (this.config.useColors && !chalk.level) {\n      logger.warn('Terminal does not support colors, disabling color output');\n      this.config.useColors = false;\n    }\n    \n    logger.debug('Terminal capabilities detected', {\n      isInteractive: this.isInteractive,\n      colorSupport: this.config.useColors ? 'yes' : 'no',\n      size: `${this.terminalWidth}x${this.terminalHeight}`\n    });\n  }\n\n  /**\n   * Display the welcome message\n   */\n  displayWelcome(): void {\n    this.clear();\n    \n    const version = '0.2.29'; // This should come from package.json\n    \n    // Main logo/header\n    console.log(chalk.blue.bold('\\n  Claude Code CLI'));\n    console.log(chalk.gray(`  Version ${version} (Research Preview)\\n`));\n    \n    console.log(chalk.white(`  Welcome! Type ${chalk.cyan('/help')} to see available commands.`));\n    console.log(chalk.white(`  You can ask Claude to explain code, fix issues, or perform tasks.`));\n    console.log(chalk.white(`  Example: \"${chalk.italic('Please analyze this codebase and explain its structure.')}\"\\n`));\n\n    if (this.config.useColors) {\n      console.log(chalk.dim('  Pro tip: Use Ctrl+C to interrupt Claude and start over.\\n'));\n    }\n  }\n\n  /**\n   * Clear the terminal screen\n   */\n  clear(): void {\n    if (this.isInteractive) {\n      clearScreen();\n    }\n  }\n\n  /**\n   * Display formatted content\n   */\n  display(content: string): void {\n    const formatted = formatOutput(content, {\n      width: this.terminalWidth,\n      colors: this.config.useColors,\n      codeHighlighting: this.config.codeHighlighting\n    });\n    \n    console.log(formatted);\n  }\n\n  /**\n   * Display a message with emphasis\n   */\n  emphasize(message: string): void {\n    if (this.config.useColors) {\n      console.log(chalk.cyan.bold(message));\n    } else {\n      console.log(message.toUpperCase());\n    }\n  }\n\n  /**\n   * Display an informational message\n   */\n  info(message: string): void {\n    if (this.config.useColors) {\n      console.log(chalk.blue(`ℹ ${message}`));\n    } else {\n      console.log(`INFO: ${message}`);\n    }\n  }\n\n  /**\n   * Display a success message\n   */\n  success(message: string): void {\n    if (this.config.useColors) {\n      console.log(chalk.green(`✓ ${message}`));\n    } else {\n      console.log(`SUCCESS: ${message}`);\n    }\n  }\n\n  /**\n   * Display a warning message\n   */\n  warn(message: string): void {\n    if (this.config.useColors) {\n      console.log(chalk.yellow(`⚠ ${message}`));\n    } else {\n      console.log(`WARNING: ${message}`);\n    }\n  }\n\n  /**\n   * Display an error message\n   */\n  error(message: string): void {\n    if (this.config.useColors) {\n      console.log(chalk.red(`✗ ${message}`));\n    } else {\n      console.log(`ERROR: ${message}`);\n    }\n  }\n\n  /**\n   * Create a clickable link in the terminal if supported\n   */\n  link(text: string, url: string): string {\n    return terminalLink(text, url, { fallback: (text: string, url: string) => `${text} (${url})` });\n  }\n\n  /**\n   * Display a table of data\n   */\n  table(data: any[][], options: { header?: string[]; border?: boolean } = {}): void {\n    const config: any = {\n      border: options.border ? {} : { topBody: '', topJoin: '', topLeft: '', topRight: '', bottomBody: '', bottomJoin: '', bottomLeft: '', bottomRight: '', bodyLeft: '', bodyRight: '', bodyJoin: '', joinBody: '', joinLeft: '', joinRight: '', joinJoin: '' }\n    };\n    \n    // Add header row with formatting\n    if (options.header) {\n      if (this.config.useColors) {\n        data = [options.header.map(h => chalk.bold(h)), ...data];\n      } else {\n        data = [options.header, ...data];\n      }\n    }\n    \n    console.log(table(data, config));\n  }\n\n  /**\n   * Prompt user for input\n   */\n  async prompt<T>(options: PromptOptions): Promise<T> {\n    return createPrompt(options, this.config);\n  }\n\n  /**\n   * Create a spinner for showing progress\n   */\n  spinner(text: string, id: string = 'default'): SpinnerInstance {\n    // Clean up existing spinner with the same ID\n    if (this.activeSpinners.has(id)) {\n      this.activeSpinners.get(id)!.stop();\n      this.activeSpinners.delete(id);\n    }\n    \n    // Create spinner only if progress indicators are enabled and terminal is interactive\n    if (this.config.showProgressIndicators && this.isInteractive) {\n      const spinner = ora({\n        text,\n        spinner: 'dots',\n        color: 'cyan'\n      }).start();\n      \n      const spinnerInstance: SpinnerInstance = {\n        id,\n        update: (newText: string) => {\n          spinner.text = newText;\n          return spinnerInstance;\n        },\n        succeed: (text?: string) => {\n          spinner.succeed(text);\n          this.activeSpinners.delete(id);\n          return spinnerInstance;\n        },\n        fail: (text?: string) => {\n          spinner.fail(text);\n          this.activeSpinners.delete(id);\n          return spinnerInstance;\n        },\n        warn: (text?: string) => {\n          spinner.warn(text);\n          this.activeSpinners.delete(id);\n          return spinnerInstance;\n        },\n        info: (text?: string) => {\n          spinner.info(text);\n          this.activeSpinners.delete(id);\n          return spinnerInstance;\n        },\n        stop: () => {\n          spinner.stop();\n          this.activeSpinners.delete(id);\n          return spinnerInstance;\n        }\n      };\n      \n      this.activeSpinners.set(id, spinnerInstance);\n      return spinnerInstance;\n    } else {\n      // Fallback for non-interactive terminals or when progress indicators are disabled\n      console.log(text);\n      \n      // Return a dummy spinner\n      const dummySpinner: SpinnerInstance = {\n        id,\n        update: (newText: string) => {\n          if (newText !== text) {\n            console.log(newText);\n          }\n          return dummySpinner;\n        },\n        succeed: (text?: string) => {\n          if (text) {\n            this.success(text);\n          }\n          return dummySpinner;\n        },\n        fail: (text?: string) => {\n          if (text) {\n            this.error(text);\n          }\n          return dummySpinner;\n        },\n        warn: (text?: string) => {\n          if (text) {\n            this.warn(text);\n          }\n          return dummySpinner;\n        },\n        info: (text?: string) => {\n          if (text) {\n            this.info(text);\n          }\n          return dummySpinner;\n        },\n        stop: () => {\n          return dummySpinner;\n        }\n      };\n      \n      return dummySpinner;\n    }\n  }\n}\n\n// Re-export the types\nexport * from './types.js'; ","/**\n * Terminal Formatting Utilities\n * \n * Provides functions for formatting and displaying text in the terminal.\n */\n\nimport chalk from 'chalk';\n\n/**\n * Clear the terminal screen\n */\nexport function clearScreen(): void {\n  // Clear screen and move cursor to top-left\n  process.stdout.write('\\x1b[2J\\x1b[0f');\n}\n\n/**\n * Get the terminal size (rows and columns)\n */\nexport function getTerminalSize(): { rows: number; columns: number } {\n  // Default to a reasonable size if we can't determine the actual size\n  const defaultSize = { rows: 24, columns: 80 };\n  \n  try {\n    if (process.stdout.isTTY) {\n      return {\n        rows: process.stdout.rows || defaultSize.rows,\n        columns: process.stdout.columns || defaultSize.columns\n      };\n    }\n  } catch (error) {\n    // Ignore errors\n  }\n  \n  return defaultSize;\n}\n\n/**\n * Options for formatting output\n */\nexport interface FormatOptions {\n  /**\n   * Terminal width in columns\n   */\n  width?: number;\n  \n  /**\n   * Whether to use colors\n   */\n  colors?: boolean;\n  \n  /**\n   * Whether to highlight code\n   */\n  codeHighlighting?: boolean;\n}\n\n/**\n * Format output for display in the terminal\n */\nexport function formatOutput(text: string, options: FormatOptions = {}): string {\n  const { width = getTerminalSize().columns, colors = true, codeHighlighting = true } = options;\n  \n  if (!text) {\n    return '';\n  }\n  \n  // Process markdown-like formatting if colors are enabled\n  if (colors) {\n    // Format code blocks with syntax highlighting\n    text = formatCodeBlocks(text, codeHighlighting);\n    \n    // Format inline code\n    text = text.replace(/`([^`]+)`/g, (_, code) => chalk.cyan(code));\n    \n    // Format bold text\n    text = text.replace(/\\*\\*([^*]+)\\*\\*/g, (_, bold) => chalk.bold(bold));\n    \n    // Format italic text\n    text = text.replace(/\\*([^*]+)\\*/g, (_, italic) => chalk.italic(italic));\n    \n    // Format lists\n    text = text.replace(/^(\\s*)-\\s+(.+)$/gm, (_, indent, item) => \n      `${indent}${chalk.dim('•')} ${item}`\n    );\n    \n    // Format headers\n    text = text.replace(/^(#+)\\s+(.+)$/gm, (_, hashes, header) => {\n      if (hashes.length === 1) {\n        return chalk.bold.underline.blue(header);\n      } else if (hashes.length === 2) {\n        return chalk.bold.blue(header);\n      } else {\n        return chalk.bold(header);\n      }\n    });\n  }\n  \n  // Word wrap if width is specified\n  if (width) {\n    text = wordWrap(text, width);\n  }\n  \n  return text;\n}\n\n/**\n * Format code blocks with syntax highlighting\n */\nfunction formatCodeBlocks(text: string, enableHighlighting: boolean): string {\n  const codeBlockRegex = /```(\\w+)?\\n([\\s\\S]+?)```/g;\n  \n  return text.replace(codeBlockRegex, (match, language, code) => {\n    // Add syntax highlighting if enabled\n    const highlightedCode = enableHighlighting && language\n      ? highlightSyntax(code, language)\n      : code;\n    \n    // Format the code block with a border\n    const lines = highlightedCode.split('\\n');\n    const border = chalk.dim('┃');\n    \n    const formattedLines = lines.map((line: string) => `${border} ${line}`);\n    const top = chalk.dim('┏' + '━'.repeat(Math.max(...lines.map((l: string) => l.length)) + 2) + '┓');\n    const bottom = chalk.dim('┗' + '━'.repeat(Math.max(...lines.map((l: string) => l.length)) + 2) + '┛');\n    \n    // Add language indicator if present\n    const header = language \n      ? `${border} ${chalk.bold.blue(language)}\\n`\n      : '';\n    \n    return `${top}\\n${header}${formattedLines.join('\\n')}\\n${bottom}`;\n  });\n}\n\n/**\n * Simple syntax highlighting for code\n */\nfunction highlightSyntax(code: string, language: string): string {\n  // Basic syntax highlighting - in a real app, use a proper library\n  // This is just a simple example with a few patterns\n  \n  // Common programming keywords\n  const keywords = [\n    'function', 'const', 'let', 'var', 'if', 'else', 'for', 'while', 'return',\n    'import', 'export', 'class', 'interface', 'extends', 'implements',\n    'public', 'private', 'protected', 'static', 'async', 'await'\n  ];\n  \n  // Split by tokens that we want to preserve\n  const tokens = code.split(/(\\s+|[{}[\\]();,.<>?:!+\\-*/%&|^~=])/);\n  \n  return tokens.map(token => {\n    // Keywords\n    if (keywords.includes(token)) {\n      return chalk.blue(token);\n    }\n    \n    // Numbers\n    if (/^[0-9]+(\\.[0-9]+)?$/.test(token)) {\n      return chalk.yellow(token);\n    }\n    \n    // Strings\n    if (/^[\"'].*[\"']$/.test(token)) {\n      return chalk.green(token);\n    }\n    \n    // Comments\n    if (token.startsWith('//') || token.startsWith('/*') || token.startsWith('*')) {\n      return chalk.gray(token);\n    }\n    \n    return token;\n  }).join('');\n}\n\n/**\n * Word wrap text to the specified width\n */\nexport function wordWrap(text: string, width: number): string {\n  const lines = text.split('\\n');\n  \n  return lines.map(line => {\n    // If the line is a code block or already shorter than the width, leave it as is\n    if (line.trim().startsWith('┃') || line.length <= width) {\n      return line;\n    }\n    \n    // Word wrap the line\n    const words = line.split(' ');\n    const wrappedLines: string[] = [];\n    let currentLine = '';\n    \n    for (const word of words) {\n      // If adding this word would exceed the width\n      if (currentLine.length + word.length + 1 > width) {\n        // Add the current line to wrapped lines if it's not empty\n        if (currentLine) {\n          wrappedLines.push(currentLine);\n          currentLine = word;\n        } else {\n          // If the current line is empty, it means the word itself is longer than the width\n          wrappedLines.push(word);\n        }\n      } else {\n        // Add the word to the current line\n        currentLine = currentLine ? `${currentLine} ${word}` : word;\n      }\n    }\n    \n    // Add the last line if it's not empty\n    if (currentLine) {\n      wrappedLines.push(currentLine);\n    }\n    \n    return wrappedLines.join('\\n');\n  }).join('\\n');\n} ","/**\n * Terminal Prompts\n * \n * Provides functions for creating and handling user prompts in the terminal.\n */\n\nimport { createInterface, Interface } from 'readline';\nimport { EventEmitter } from 'events';\nimport { PromptOptions, TerminalConfig } from './types.js';\nimport { logger } from '../utils/logger.js';\nimport inquirer from 'inquirer';\n\nexport class Prompt extends EventEmitter {\n  private rl: Interface;\n  private options: PromptOptions;\n  private config: TerminalConfig;\n\n  constructor(options: PromptOptions, config: TerminalConfig) {\n    super();\n    this.options = options;\n    this.config = config;\n    this.rl = createInterface({\n      input: process.stdin,\n      output: process.stdout\n    });\n  }\n\n  async run(): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const query = `${this.options.message} `;\n      this.rl.question(query, (answer) => {\n        this.rl.close();\n        resolve(answer);\n      });\n    });\n  }\n}\n\n/**\n * Create and display a prompt for user input\n */\nexport async function createPrompt<T>(options: PromptOptions, config: TerminalConfig): Promise<T> {\n  logger.debug('Creating prompt', { type: options.type, name: options.name });\n  \n  // Add validation for required fields\n  if (options.required && !options.validate) {\n    options.validate = (input: any) => {\n      if (!input && input !== false && input !== 0) {\n        return `${options.name} is required`;\n      }\n      return true;\n    };\n  }\n  \n  // Handle non-interactive terminals\n  if (!process.stdin.isTTY || !process.stdout.isTTY) {\n    logger.warn('Terminal is not interactive, cannot prompt for input');\n    throw new Error('Cannot prompt for input in non-interactive terminal');\n  }\n  \n  try {\n    // Use Inquirer to create the prompt\n    const result = await inquirer.prompt([options as any]);\n    \n    logger.debug('Prompt result', { name: options.name, result: result[options.name] });\n    \n    return result[options.name];\n  } catch (error) {\n    logger.error('Error in prompt', error);\n    throw new Error(`Failed to prompt for ${options.name}: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n/**\n * Create a text input prompt\n */\nexport async function promptText(message: string, options: {\n  name?: string;\n  default?: string;\n  required?: boolean;\n  validate?: (input: string) => boolean | string | Promise<boolean | string>;\n} = {}): Promise<string> {\n  const result = await createPrompt<{ [key: string]: string }>({\n    type: 'input',\n    name: options.name || 'input',\n    message,\n    default: options.default,\n    required: options.required,\n    validate: options.validate\n  }, { theme: 'system', useColors: true, showProgressIndicators: true, codeHighlighting: true });\n  \n  return result[options.name || 'input'];\n}\n\n/**\n * Create a password input prompt\n */\nexport async function promptPassword(message: string, options: {\n  name?: string;\n  mask?: string;\n  required?: boolean;\n} = {}): Promise<string> {\n  const result = await createPrompt<{ [key: string]: string }>({\n    type: 'password',\n    name: options.name || 'password',\n    message,\n    mask: options.mask || '*',\n    required: options.required\n  }, { theme: 'system', useColors: true, showProgressIndicators: true, codeHighlighting: true });\n  \n  return result[options.name || 'password'];\n}\n\n/**\n * Create a confirmation prompt\n */\nexport async function promptConfirm(message: string, options: {\n  name?: string;\n  default?: boolean;\n} = {}): Promise<boolean> {\n  const result = await createPrompt<{ [key: string]: boolean }>({\n    type: 'confirm',\n    name: options.name || 'confirm',\n    message,\n    default: options.default\n  }, { theme: 'system', useColors: true, showProgressIndicators: true, codeHighlighting: true });\n  \n  return result[options.name || 'confirm'];\n}\n\n/**\n * Create a selection list prompt\n */\nexport async function promptList<T>(message: string, choices: Array<string | { name: string; value: T; short?: string }>, options: {\n  name?: string;\n  default?: T;\n  pageSize?: number;\n} = {}): Promise<T> {\n  const result = await createPrompt<{ [key: string]: T }>({\n    type: 'list',\n    name: options.name || 'list',\n    message,\n    choices,\n    default: options.default,\n    pageSize: options.pageSize\n  }, { theme: 'system', useColors: true, showProgressIndicators: true, codeHighlighting: true });\n  \n  return result[options.name || 'list'];\n}\n\n/**\n * Create a multi-select checkbox prompt\n */\nexport async function promptCheckbox<T>(message: string, choices: Array<string | { name: string; value: T; checked?: boolean; disabled?: boolean | string }>, options: {\n  name?: string;\n  pageSize?: number;\n} = {}): Promise<T[]> {\n  const result = await createPrompt<{ [key: string]: T[] }>({\n    type: 'checkbox',\n    name: options.name || 'checkbox',\n    message,\n    choices,\n    pageSize: options.pageSize\n  }, { theme: 'system', useColors: true, showProgressIndicators: true, codeHighlighting: true });\n  \n  return result[options.name || 'checkbox'];\n}\n\n/**\n * Create an editor prompt\n */\nexport async function promptEditor(message: string, options: {\n  name?: string;\n  default?: string;\n  postfix?: string;\n} = {}): Promise<string> {\n  const result = await createPrompt<{ [key: string]: string }>({\n    type: 'editor',\n    name: options.name || 'editor',\n    message,\n    default: options.default,\n    postfix: options.postfix\n  }, { theme: 'system', useColors: true, showProgressIndicators: true, codeHighlighting: true });\n  \n  return result[options.name || 'editor'];\n} ","/**\n * Authentication Tokens\n * \n * Handles token storage, validation, and refreshing for authentication.\n */\n\nimport * as keytar from 'keytar';\nimport { logger } from '../utils/logger.js';\nimport { AuthToken, TokenStorage } from './types.js';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport os from 'os';\n\nconst TOKEN_FILE_PATH = path.join(os.homedir(), '.claude-code-auth.json');\nconst KEYCHAIN_SERVICE = 'claude-code-cli';\nconst KEYCHAIN_ACCOUNT = 'claude-code-credentials';\n\n/**\n * Create a token storage provider\n */\nexport function createTokenStorage(): TokenStorage {\n  return {\n    /**\n     * Save a token to storage\n     */\n    async saveToken(key: string, token: AuthToken): Promise<void> {\n      logger.debug(`Saving auth token for ${key}`);\n      try {\n        const data = JSON.stringify({ [key]: token });\n        await fs.writeFile(TOKEN_FILE_PATH, data);\n      } catch (error) {\n        logger.error('Failed to save token to file', error);\n      }\n    },\n    \n    /**\n     * Get a token from storage\n     */\n    async getToken(key: string): Promise<AuthToken | null> {\n      logger.debug(`Getting auth token for ${key}`);\n      try {\n        const data = await fs.readFile(TOKEN_FILE_PATH, 'utf-8');\n        const tokens = JSON.parse(data);\n        return tokens[key] || null;\n      } catch (error) {\n        if (error instanceof Error && 'code' in error && error.code === 'ENOENT') {\n          return null;\n        }\n        logger.error('Failed to read token from file', error);\n        return null;\n      }\n    },\n    \n    /**\n     * Delete a token from storage\n     */\n    async deleteToken(key: string): Promise<void> {\n      logger.debug(`Deleting auth token for ${key}`);\n      try {\n        const data = await fs.readFile(TOKEN_FILE_PATH, 'utf-8');\n        const tokens = JSON.parse(data);\n        delete tokens[key];\n        await fs.writeFile(TOKEN_FILE_PATH, JSON.stringify(tokens));\n      } catch (error) {\n        if (!(error instanceof Error && 'code' in error && error.code === 'ENOENT')) {\n          logger.error('Failed to delete token from file', error);\n        }\n      }\n    },\n    \n    /**\n     * Clear all tokens from storage\n     */\n    async clearTokens(): Promise<void> {\n      logger.debug('Clearing all auth tokens');\n      try {\n        await fs.unlink(TOKEN_FILE_PATH);\n      } catch (error) {\n        if (!(error instanceof Error && 'code' in error && error.code === 'ENOENT')) {\n          logger.error('Failed to clear tokens', error);\n        }\n      }\n    }\n  };\n}\n\n/**\n * Check if a token is expired\n */\nexport function isTokenExpired(token: AuthToken, thresholdSeconds: number = 0): boolean {\n  if (!token.expiresAt) {\n    return false;\n  }\n  \n  const now = Math.floor(Date.now() / 1000);\n  return token.expiresAt - now <= thresholdSeconds;\n}\n\n/**\n * Validate a token\n */\nexport function validateToken(token: AuthToken): boolean {\n  // Check if token has required fields\n  if (!token.accessToken) {\n    return false;\n  }\n  \n  // Check if token is expired\n  if (isTokenExpired(token)) {\n    return false;\n  }\n  \n  return true;\n}\n\n/**\n * Format an expiration timestamp\n */\nexport function formatTokenExpiration(expiresAt: number): string {\n  if (!expiresAt) {\n    return 'never';\n  }\n  \n  const date = new Date(expiresAt * 1000);\n  return date.toLocaleString();\n}\n\n/**\n * Get token details for display\n */\nexport function getTokenDetails(token: AuthToken): Record<string, string> {\n  const details: Record<string, string> = {};\n  \n  // Get token type\n  details.type = token.tokenType || 'Bearer';\n  \n  // Get token expiration\n  if (token.expiresAt) {\n    details.expires = formatTokenExpiration(token.expiresAt);\n    \n    const now = Math.floor(Date.now() / 1000);\n    const expiresIn = token.expiresAt - now;\n    \n    if (expiresIn > 0) {\n      details.expiresIn = `${Math.floor(expiresIn / 60)} minutes`;\n    } else {\n      details.expiresIn = 'Expired';\n    }\n  } else {\n    details.expires = 'Never';\n  }\n  \n  // Get token scope\n  if (token.scope) {\n    details.scope = token.scope;\n  }\n  \n  // Get token ID if available\n  if (token.id) {\n    details.id = token.id;\n  }\n  \n  // Mask the access token\n  if (token.accessToken) {\n    const tokenLength = token.accessToken.length;\n    details.accessToken = `${token.accessToken.substring(0, 4)}...${token.accessToken.substring(tokenLength - 4)}`;\n  }\n  \n  return details;\n}\n\n/**\n * Extract token from an authorization header\n */\nexport function extractTokenFromHeader(header: string): string | null {\n  if (!header) {\n    return null;\n  }\n  \n  // Check for Bearer token\n  if (header.startsWith('Bearer ')) {\n    return header.substring(7).trim();\n  }\n  \n  // Check for token without prefix\n  if (!header.includes(' ')) {\n    return header.trim();\n  }\n  \n  return null;\n}\n\n/**\n * Create an authorization header from a token\n */\nexport function createAuthorizationHeader(token: AuthToken): string {\n  const tokenType = token.tokenType || 'Bearer';\n  return `${tokenType} ${token.accessToken}`;\n} ","/**\n * Async Utilities\n * \n * Provides utilities for handling asynchronous operations,\n * timeouts, retries, and other async patterns.\n */\n\nimport { logger } from './logger.js';\n\n/**\n * Options for retry operations\n */\nexport interface RetryOptions {\n  /**\n   * Maximum number of retry attempts\n   */\n  maxRetries: number;\n  \n  /**\n   * Initial delay in milliseconds before the first retry\n   */\n  initialDelayMs: number;\n  \n  /**\n   * Maximum delay in milliseconds between retries\n   */\n  maxDelayMs: number;\n  \n  /**\n   * Whether to use exponential backoff (true) or constant delay (false)\n   */\n  backoff?: boolean;\n  \n  /**\n   * Optional function to determine if an error is retryable\n   */\n  isRetryable?: (error: Error) => boolean;\n  \n  /**\n   * Optional callback to execute before each retry\n   */\n  onRetry?: (error: Error, attempt: number) => void;\n}\n\n/**\n * Default retry options\n */\nconst DEFAULT_RETRY_OPTIONS: RetryOptions = {\n  maxRetries: 3,\n  initialDelayMs: 1000,\n  maxDelayMs: 10000\n};\n\n/**\n * Sleep for the specified number of milliseconds\n */\nexport async function delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Execute a function with a timeout\n * \n * @param fn Function to execute with timeout\n * @param timeoutMs Timeout in milliseconds\n * @returns A function that wraps the original function with timeout\n */\nexport function withTimeout<T extends (...args: any[]) => Promise<any>>(\n  fn: T,\n  timeoutMs: number\n): (...args: Parameters<T>) => Promise<ReturnType<T>> {\n  return async (...args: Parameters<T>): Promise<ReturnType<T>> => {\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        const error = new Error(`Operation timed out after ${timeoutMs}ms`);\n        error.name = 'TimeoutError';\n        reject(error);\n      }, timeoutMs);\n      \n      fn(...args)\n        .then(result => {\n          clearTimeout(timeoutId);\n          resolve(result);\n        })\n        .catch(error => {\n          clearTimeout(timeoutId);\n          reject(error);\n        });\n    });\n  };\n}\n\n/**\n * Execute a function with retry logic\n * \n * @param fn Function to execute with retry logic\n * @param options Retry options \n * @returns A function that wraps the original function with retry logic\n */\nexport function withRetry<T extends (...args: any[]) => Promise<any>>(\n  fn: T,\n  options: Partial<RetryOptions> = {}\n): (...args: Parameters<T>) => Promise<ReturnType<T>> {\n  // Set default retry options\n  const retryOptions: RetryOptions = {\n    maxRetries: options.maxRetries ?? 3,\n    initialDelayMs: options.initialDelayMs ?? 1000,\n    maxDelayMs: options.maxDelayMs ?? 10000,\n    backoff: options.backoff ?? true,\n    isRetryable: options.isRetryable,\n    onRetry: options.onRetry\n  };\n  \n  // Return a function that wraps the original function with retry logic\n  return async (...args: Parameters<T>): Promise<ReturnType<T>> => {\n    let lastError: Error = new Error('Unknown error');\n    \n    for (let attempt = 0; attempt <= retryOptions.maxRetries; attempt++) {\n      try {\n        // First attempt (attempt = 0) doesn't count as a retry\n        if (attempt === 0) {\n          return await fn(...args);\n        }\n        \n        // Wait before retry\n        const delayMs = calculateRetryDelay(attempt, retryOptions);\n        await delay(delayMs);\n        \n        // Execute retry callback if provided\n        if (retryOptions.onRetry) {\n          retryOptions.onRetry(lastError, attempt);\n        }\n        \n        // Execute the function\n        return await fn(...args);\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n        \n        // Check if we've reached the maximum number of retries\n        if (attempt >= retryOptions.maxRetries) {\n          throw lastError;\n        }\n        \n        // Check if the error is retryable\n        if (retryOptions.isRetryable && !retryOptions.isRetryable(lastError)) {\n          throw lastError;\n        }\n      }\n    }\n    \n    // This should never be reached, but TypeScript needs a return\n    throw lastError;\n  };\n}\n\n/**\n * Calculate the delay time for a retry attempt\n */\nfunction calculateRetryDelay(attempt: number, options: RetryOptions): number {\n  if (!options.backoff) {\n    return options.initialDelayMs;\n  }\n  \n  // Exponential backoff: initialDelay * 2^(attempt-1)\n  const exponentialDelay = options.initialDelayMs * Math.pow(2, attempt - 1);\n  \n  // Add some jitter (±10%) to avoid retry stampedes\n  const jitter = 0.1 * exponentialDelay;\n  const jitteredDelay = exponentialDelay - jitter + (Math.random() * jitter * 2);\n  \n  // Cap at maximum delay\n  return Math.min(jitteredDelay, options.maxDelayMs);\n}\n\n/**\n * Run operations in parallel with a concurrency limit\n */\nexport async function withConcurrency<T, R>(\n  items: T[],\n  fn: (item: T, index: number) => Promise<R>,\n  concurrency: number = 5\n): Promise<R[]> {\n  if (!items.length) return [];\n  \n  const results: R[] = new Array(items.length);\n  let currentIndex = 0;\n  \n  const workers = Array.from({ length: Math.min(concurrency, items.length) }, async (_, workerId) => {\n    while (currentIndex < items.length) {\n      const index = currentIndex++;\n      logger.debug(`Worker ${workerId} processing item ${index}`);\n      \n      try {\n        results[index] = await fn(items[index], index);\n      } catch (error) {\n        logger.error(`Error processing item ${index}`, error);\n        throw error; // Fail fast\n      }\n    }\n  });\n  \n  await Promise.all(workers);\n  return results;\n}\n\n/**\n * Create a debounced version of a function\n * \n * @param fn Function to debounce\n * @param waitMs Wait time in milliseconds\n * @param options Debounce options\n * @returns Debounced function\n */\nexport function debounce<T extends (...args: any[]) => any>(\n  fn: T,\n  waitMs: number,\n  options: { leading?: boolean; trailing?: boolean; maxWait?: number } = {}\n): (...args: Parameters<T>) => void {\n  let timeout: ReturnType<typeof setTimeout> | null = null;\n  let lastArgs: Parameters<T> | null = null;\n  let lastCallTime: number | null = null;\n  let lastInvokeTime = 0;\n  \n  const leading = options.leading ?? false;\n  const trailing = options.trailing ?? true;\n  const maxWait = options.maxWait;\n  \n  // Check if we should invoke the function\n  function shouldInvoke(time: number): boolean {\n    if (lastCallTime === null) {\n      return true;\n    }\n    \n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    \n    // Invoke if:\n    // 1. It's the first call, or\n    // 2. We've waited long enough since the last call, or\n    // 3. We've reached the maximum wait time (if defined)\n    return (\n      lastCallTime === null ||\n      timeSinceLastCall >= waitMs ||\n      (maxWait !== undefined && timeSinceLastInvoke >= maxWait)\n    );\n  }\n  \n  // Invoke the function\n  function invokeFunc(time: number): void {\n    const args = lastArgs!;\n    lastArgs = null;\n    lastInvokeTime = time;\n    \n    fn(...args);\n  }\n  \n  // Handle the trailing edge invocation\n  function trailingEdge(time: number): void {\n    timeout = null;\n    \n    if (trailing && lastArgs) {\n      invokeFunc(time);\n    }\n    \n    lastArgs = null;\n  }\n  \n  // Start the timer for the trailing edge\n  function startTimer(): void {\n    timeout = setTimeout(() => {\n      const time = Date.now();\n      trailingEdge(time);\n    }, waitMs);\n  }\n  \n  // Handle a new function call\n  function timerExpired(): void {\n    const time = Date.now();\n    \n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    \n    // Restart the timer\n    timeout = setTimeout(timerExpired, Math.min(\n      waitMs - (time - lastCallTime!),\n      maxWait !== undefined ? maxWait - (time - lastInvokeTime) : waitMs\n    ));\n  }\n  \n  // Leading edge invocation\n  function leadingEdge(time: number): void {\n    lastInvokeTime = time;\n    \n    // Start the timer for trailing edge\n    startTimer();\n    \n    // Invoke the function\n    if (leading) {\n      invokeFunc(time);\n    }\n  }\n  \n  // The debounced function\n  return function debouncedFunction(...args: Parameters<T>): void {\n    const time = Date.now();\n    lastArgs = args;\n    lastCallTime = time;\n    \n    const isInvoking = shouldInvoke(time);\n    \n    if (isInvoking) {\n      if (timeout === null) {\n        leadingEdge(time);\n        return;\n      }\n      \n      if (maxWait !== undefined) {\n        // Handle maxWait\n        timeout = setTimeout(timerExpired, maxWait);\n      }\n    } else if (timeout === null && trailing) {\n      // Start timer for trailing edge\n      startTimer();\n    }\n  };\n}\n\n/**\n * Create a throttled version of a function\n * \n * @param fn Function to throttle\n * @param waitMs Wait time in milliseconds\n * @param options Throttle options\n * @returns Throttled function\n */\nexport function throttle<T extends (...args: any[]) => any>(\n  fn: T,\n  waitMs: number,\n  options: { leading?: boolean; trailing?: boolean } = {}\n): (...args: Parameters<T>) => void {\n  const leading = options.leading ?? true;\n  const trailing = options.trailing ?? true;\n  \n  // Use debounce with maxWait equal to waitMs\n  return debounce(fn, waitMs, {\n    leading,\n    trailing,\n    maxWait: waitMs\n  });\n}\n\n/**\n * Create a deferred promise\n */\nexport function createDeferred<T>(): {\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (reason?: any) => void;\n} {\n  let resolve!: (value: T) => void;\n  let reject!: (reason?: any) => void;\n  \n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  \n  return { promise, resolve, reject };\n}\n\n/**\n * Run functions in sequence\n */\nexport async function runSequentially<T>(\n  fns: Array<() => Promise<T>>\n): Promise<T[]> {\n  const results: T[] = [];\n  \n  for (const fn of fns) {\n    results.push(await fn());\n  }\n  \n  return results;\n}\n\nexport default {\n  delay,\n  withTimeout,\n  withRetry,\n  withConcurrency,\n  debounce,\n  throttle,\n  createDeferred,\n  runSequentially\n}; ","import process from 'node:process';\nimport {Buffer} from 'node:buffer';\nimport path from 'node:path';\nimport {fileURLToPath} from 'node:url';\nimport childProcess from 'node:child_process';\nimport fs, {constants as fsConstants} from 'node:fs/promises';\nimport isWsl from 'is-wsl';\nimport defineLazyProperty from 'define-lazy-prop';\nimport defaultBrowser from 'default-browser';\nimport isInsideContainer from 'is-inside-container';\n\n// Path to included `xdg-open`.\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\nconst localXdgOpenPath = path.join(__dirname, 'xdg-open');\n\nconst {platform, arch} = process;\n\n/**\nGet the mount point for fixed drives in WSL.\n\n@inner\n@returns {string} The mount point.\n*/\nconst getWslDrivesMountPoint = (() => {\n\t// Default value for \"root\" param\n\t// according to https://docs.microsoft.com/en-us/windows/wsl/wsl-config\n\tconst defaultMountPoint = '/mnt/';\n\n\tlet mountPoint;\n\n\treturn async function () {\n\t\tif (mountPoint) {\n\t\t\t// Return memoized mount point value\n\t\t\treturn mountPoint;\n\t\t}\n\n\t\tconst configFilePath = '/etc/wsl.conf';\n\n\t\tlet isConfigFileExists = false;\n\t\ttry {\n\t\t\tawait fs.access(configFilePath, fsConstants.F_OK);\n\t\t\tisConfigFileExists = true;\n\t\t} catch {}\n\n\t\tif (!isConfigFileExists) {\n\t\t\treturn defaultMountPoint;\n\t\t}\n\n\t\tconst configContent = await fs.readFile(configFilePath, {encoding: 'utf8'});\n\t\tconst configMountPoint = /(?<!#.*)root\\s*=\\s*(?<mountPoint>.*)/g.exec(configContent);\n\n\t\tif (!configMountPoint) {\n\t\t\treturn defaultMountPoint;\n\t\t}\n\n\t\tmountPoint = configMountPoint.groups.mountPoint.trim();\n\t\tmountPoint = mountPoint.endsWith('/') ? mountPoint : `${mountPoint}/`;\n\n\t\treturn mountPoint;\n\t};\n})();\n\nconst pTryEach = async (array, mapper) => {\n\tlet latestError;\n\n\tfor (const item of array) {\n\t\ttry {\n\t\t\treturn await mapper(item); // eslint-disable-line no-await-in-loop\n\t\t} catch (error) {\n\t\t\tlatestError = error;\n\t\t}\n\t}\n\n\tthrow latestError;\n};\n\nconst baseOpen = async options => {\n\toptions = {\n\t\twait: false,\n\t\tbackground: false,\n\t\tnewInstance: false,\n\t\tallowNonzeroExitCode: false,\n\t\t...options,\n\t};\n\n\tif (Array.isArray(options.app)) {\n\t\treturn pTryEach(options.app, singleApp => baseOpen({\n\t\t\t...options,\n\t\t\tapp: singleApp,\n\t\t}));\n\t}\n\n\tlet {name: app, arguments: appArguments = []} = options.app ?? {};\n\tappArguments = [...appArguments];\n\n\tif (Array.isArray(app)) {\n\t\treturn pTryEach(app, appName => baseOpen({\n\t\t\t...options,\n\t\t\tapp: {\n\t\t\t\tname: appName,\n\t\t\t\targuments: appArguments,\n\t\t\t},\n\t\t}));\n\t}\n\n\tif (app === 'browser' || app === 'browserPrivate') {\n\t\t// IDs from default-browser for macOS and windows are the same\n\t\tconst ids = {\n\t\t\t'com.google.chrome': 'chrome',\n\t\t\t'google-chrome.desktop': 'chrome',\n\t\t\t'org.mozilla.firefox': 'firefox',\n\t\t\t'firefox.desktop': 'firefox',\n\t\t\t'com.microsoft.msedge': 'edge',\n\t\t\t'com.microsoft.edge': 'edge',\n\t\t\t'microsoft-edge.desktop': 'edge',\n\t\t};\n\n\t\t// Incognito flags for each browser in `apps`.\n\t\tconst flags = {\n\t\t\tchrome: '--incognito',\n\t\t\tfirefox: '--private-window',\n\t\t\tedge: '--inPrivate',\n\t\t};\n\n\t\tconst browser = await defaultBrowser();\n\t\tif (browser.id in ids) {\n\t\t\tconst browserName = ids[browser.id];\n\n\t\t\tif (app === 'browserPrivate') {\n\t\t\t\tappArguments.push(flags[browserName]);\n\t\t\t}\n\n\t\t\treturn baseOpen({\n\t\t\t\t...options,\n\t\t\t\tapp: {\n\t\t\t\t\tname: apps[browserName],\n\t\t\t\t\targuments: appArguments,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tthrow new Error(`${browser.name} is not supported as a default browser`);\n\t}\n\n\tlet command;\n\tconst cliArguments = [];\n\tconst childProcessOptions = {};\n\n\tif (platform === 'darwin') {\n\t\tcommand = 'open';\n\n\t\tif (options.wait) {\n\t\t\tcliArguments.push('--wait-apps');\n\t\t}\n\n\t\tif (options.background) {\n\t\t\tcliArguments.push('--background');\n\t\t}\n\n\t\tif (options.newInstance) {\n\t\t\tcliArguments.push('--new');\n\t\t}\n\n\t\tif (app) {\n\t\t\tcliArguments.push('-a', app);\n\t\t}\n\t} else if (platform === 'win32' || (isWsl && !isInsideContainer() && !app)) {\n\t\tconst mountPoint = await getWslDrivesMountPoint();\n\n\t\tcommand = isWsl\n\t\t\t? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe`\n\t\t\t: `${process.env.SYSTEMROOT || process.env.windir || 'C:\\\\Windows'}\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell`;\n\n\t\tcliArguments.push(\n\t\t\t'-NoProfile',\n\t\t\t'-NonInteractive',\n\t\t\t'-ExecutionPolicy',\n\t\t\t'Bypass',\n\t\t\t'-EncodedCommand',\n\t\t);\n\n\t\tif (!isWsl) {\n\t\t\tchildProcessOptions.windowsVerbatimArguments = true;\n\t\t}\n\n\t\tconst encodedArguments = ['Start'];\n\n\t\tif (options.wait) {\n\t\t\tencodedArguments.push('-Wait');\n\t\t}\n\n\t\tif (app) {\n\t\t\t// Double quote with double quotes to ensure the inner quotes are passed through.\n\t\t\t// Inner quotes are delimited for PowerShell interpretation with backticks.\n\t\t\tencodedArguments.push(`\"\\`\"${app}\\`\"\"`);\n\t\t\tif (options.target) {\n\t\t\t\tappArguments.push(options.target);\n\t\t\t}\n\t\t} else if (options.target) {\n\t\t\tencodedArguments.push(`\"${options.target}\"`);\n\t\t}\n\n\t\tif (appArguments.length > 0) {\n\t\t\tappArguments = appArguments.map(argument => `\"\\`\"${argument}\\`\"\"`);\n\t\t\tencodedArguments.push('-ArgumentList', appArguments.join(','));\n\t\t}\n\n\t\t// Using Base64-encoded command, accepted by PowerShell, to allow special characters.\n\t\toptions.target = Buffer.from(encodedArguments.join(' '), 'utf16le').toString('base64');\n\t} else {\n\t\tif (app) {\n\t\t\tcommand = app;\n\t\t} else {\n\t\t\t// When bundled by Webpack, there's no actual package file path and no local `xdg-open`.\n\t\t\tconst isBundled = !__dirname || __dirname === '/';\n\n\t\t\t// Check if local `xdg-open` exists and is executable.\n\t\t\tlet exeLocalXdgOpen = false;\n\t\t\ttry {\n\t\t\t\tawait fs.access(localXdgOpenPath, fsConstants.X_OK);\n\t\t\t\texeLocalXdgOpen = true;\n\t\t\t} catch {}\n\n\t\t\tconst useSystemXdgOpen = process.versions.electron\n\t\t\t\t?? (platform === 'android' || isBundled || !exeLocalXdgOpen);\n\t\t\tcommand = useSystemXdgOpen ? 'xdg-open' : localXdgOpenPath;\n\t\t}\n\n\t\tif (appArguments.length > 0) {\n\t\t\tcliArguments.push(...appArguments);\n\t\t}\n\n\t\tif (!options.wait) {\n\t\t\t// `xdg-open` will block the process unless stdio is ignored\n\t\t\t// and it's detached from the parent even if it's unref'd.\n\t\t\tchildProcessOptions.stdio = 'ignore';\n\t\t\tchildProcessOptions.detached = true;\n\t\t}\n\t}\n\n\tif (platform === 'darwin' && appArguments.length > 0) {\n\t\tcliArguments.push('--args', ...appArguments);\n\t}\n\n\t// This has to come after `--args`.\n\tif (options.target) {\n\t\tcliArguments.push(options.target);\n\t}\n\n\tconst subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);\n\n\tif (options.wait) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tsubprocess.once('error', reject);\n\n\t\t\tsubprocess.once('close', exitCode => {\n\t\t\t\tif (!options.allowNonzeroExitCode && exitCode > 0) {\n\t\t\t\t\treject(new Error(`Exited with code ${exitCode}`));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresolve(subprocess);\n\t\t\t});\n\t\t});\n\t}\n\n\tsubprocess.unref();\n\n\treturn subprocess;\n};\n\nconst open = (target, options) => {\n\tif (typeof target !== 'string') {\n\t\tthrow new TypeError('Expected a `target`');\n\t}\n\n\treturn baseOpen({\n\t\t...options,\n\t\ttarget,\n\t});\n};\n\nexport const openApp = (name, options) => {\n\tif (typeof name !== 'string' && !Array.isArray(name)) {\n\t\tthrow new TypeError('Expected a valid `name`');\n\t}\n\n\tconst {arguments: appArguments = []} = options ?? {};\n\tif (appArguments !== undefined && appArguments !== null && !Array.isArray(appArguments)) {\n\t\tthrow new TypeError('Expected `appArguments` as Array type');\n\t}\n\n\treturn baseOpen({\n\t\t...options,\n\t\tapp: {\n\t\t\tname,\n\t\t\targuments: appArguments,\n\t\t},\n\t});\n};\n\nfunction detectArchBinary(binary) {\n\tif (typeof binary === 'string' || Array.isArray(binary)) {\n\t\treturn binary;\n\t}\n\n\tconst {[arch]: archBinary} = binary;\n\n\tif (!archBinary) {\n\t\tthrow new Error(`${arch} is not supported`);\n\t}\n\n\treturn archBinary;\n}\n\nfunction detectPlatformBinary({[platform]: platformBinary}, {wsl}) {\n\tif (wsl && isWsl) {\n\t\treturn detectArchBinary(wsl);\n\t}\n\n\tif (!platformBinary) {\n\t\tthrow new Error(`${platform} is not supported`);\n\t}\n\n\treturn detectArchBinary(platformBinary);\n}\n\nexport const apps = {};\n\ndefineLazyProperty(apps, 'chrome', () => detectPlatformBinary({\n\tdarwin: 'google chrome',\n\twin32: 'chrome',\n\tlinux: ['google-chrome', 'google-chrome-stable', 'chromium'],\n}, {\n\twsl: {\n\t\tia32: '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe',\n\t\tx64: ['/mnt/c/Program Files/Google/Chrome/Application/chrome.exe', '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe'],\n\t},\n}));\n\ndefineLazyProperty(apps, 'firefox', () => detectPlatformBinary({\n\tdarwin: 'firefox',\n\twin32: 'C:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe',\n\tlinux: 'firefox',\n}, {\n\twsl: '/mnt/c/Program Files/Mozilla Firefox/firefox.exe',\n}));\n\ndefineLazyProperty(apps, 'edge', () => detectPlatformBinary({\n\tdarwin: 'microsoft edge',\n\twin32: 'msedge',\n\tlinux: ['microsoft-edge', 'microsoft-edge-dev'],\n}, {\n\twsl: '/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe',\n}));\n\ndefineLazyProperty(apps, 'browser', () => 'browser');\n\ndefineLazyProperty(apps, 'browserPrivate', () => 'browserPrivate');\n\nexport default open;\n","import process from 'node:process';\nimport os from 'node:os';\nimport fs from 'node:fs';\nimport isInsideContainer from 'is-inside-container';\n\nconst isWsl = () => {\n\tif (process.platform !== 'linux') {\n\t\treturn false;\n\t}\n\n\tif (os.release().toLowerCase().includes('microsoft')) {\n\t\tif (isInsideContainer()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\ttry {\n\t\treturn fs.readFileSync('/proc/version', 'utf8').toLowerCase().includes('microsoft')\n\t\t\t? !isInsideContainer() : false;\n\t} catch {\n\t\treturn false;\n\t}\n};\n\nexport default process.env.__IS_WSL_TEST__ ? isWsl : isWsl();\n","import fs from 'node:fs';\nimport isDocker from 'is-docker';\n\nlet cachedResult;\n\n// Podman detection\nconst hasContainerEnv = () => {\n\ttry {\n\t\tfs.statSync('/run/.containerenv');\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n};\n\nexport default function isInsideContainer() {\n\t// TODO: Use `??=` when targeting Node.js 16.\n\tif (cachedResult === undefined) {\n\t\tcachedResult = hasContainerEnv() || isDocker();\n\t}\n\n\treturn cachedResult;\n}\n","import fs from 'node:fs';\n\nlet isDockerCached;\n\nfunction hasDockerEnv() {\n\ttry {\n\t\tfs.statSync('/.dockerenv');\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nfunction hasDockerCGroup() {\n\ttry {\n\t\treturn fs.readFileSync('/proc/self/cgroup', 'utf8').includes('docker');\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport default function isDocker() {\n\t// TODO: Use `??=` when targeting Node.js 16.\n\tif (isDockerCached === undefined) {\n\t\tisDockerCached = hasDockerEnv() || hasDockerCGroup();\n\t}\n\n\treturn isDockerCached;\n}\n","export default function defineLazyProperty(object, propertyName, valueGetter) {\n\tconst define = value => Object.defineProperty(object, propertyName, {value, enumerable: true, writable: true});\n\n\tObject.defineProperty(object, propertyName, {\n\t\tconfigurable: true,\n\t\tenumerable: true,\n\t\tget() {\n\t\t\tconst result = valueGetter();\n\t\t\tdefine(result);\n\t\t\treturn result;\n\t\t},\n\t\tset(value) {\n\t\t\tdefine(value);\n\t\t}\n\t});\n\n\treturn object;\n}\n","import {promisify} from 'node:util';\nimport process from 'node:process';\nimport {execFile} from 'node:child_process';\nimport defaultBrowserId from 'default-browser-id';\nimport bundleName from 'bundle-name';\nimport windows from './windows.js';\n\nconst execFileAsync = promisify(execFile);\n\n// Inlined: https://github.com/sindresorhus/titleize/blob/main/index.js\nconst titleize = string => string.toLowerCase().replaceAll(/(?:^|\\s|-)\\S/g, x => x.toUpperCase());\n\nexport default async function defaultBrowser() {\n\tif (process.platform === 'darwin') {\n\t\tconst id = await defaultBrowserId();\n\t\tconst name = await bundleName(id);\n\t\treturn {name, id};\n\t}\n\n\tif (process.platform === 'linux') {\n\t\tconst {stdout} = await execFileAsync('xdg-mime', ['query', 'default', 'x-scheme-handler/http']);\n\t\tconst id = stdout.trim();\n\t\tconst name = titleize(id.replace(/.desktop$/, '').replace('-', ' '));\n\t\treturn {name, id};\n\t}\n\n\tif (process.platform === 'win32') {\n\t\treturn windows();\n\t}\n\n\tthrow new Error('Only macOS, Linux, and Windows are supported');\n}\n","import {promisify} from 'node:util';\nimport process from 'node:process';\nimport {execFile} from 'node:child_process';\n\nconst execFileAsync = promisify(execFile);\n\nexport default async function defaultBrowserId() {\n\tif (process.platform !== 'darwin') {\n\t\tthrow new Error('macOS only');\n\t}\n\n\tconst {stdout} = await execFileAsync('defaults', ['read', 'com.apple.LaunchServices/com.apple.launchservices.secure', 'LSHandlers']);\n\n\t// `(?!-)` is to prevent matching `LSHandlerRoleAll = \"-\";`.\n\tconst match = /LSHandlerRoleAll = \"(?!-)(?<id>[^\"]+?)\";\\s+?LSHandlerURLScheme = (?:http|https);/.exec(stdout);\n\n\treturn match?.groups.id ?? 'com.apple.Safari';\n}\n","import process from 'node:process';\nimport {promisify} from 'node:util';\nimport {execFile, execFileSync} from 'node:child_process';\n\nconst execFileAsync = promisify(execFile);\n\nexport async function runAppleScript(script, {humanReadableOutput = true} = {}) {\n\tif (process.platform !== 'darwin') {\n\t\tthrow new Error('macOS only');\n\t}\n\n\tconst outputArguments = humanReadableOutput ? [] : ['-ss'];\n\n\tconst {stdout} = await execFileAsync('osascript', ['-e', script, outputArguments]);\n\treturn stdout.trim();\n}\n\nexport function runAppleScriptSync(script, {humanReadableOutput = true} = {}) {\n\tif (process.platform !== 'darwin') {\n\t\tthrow new Error('macOS only');\n\t}\n\n\tconst outputArguments = humanReadableOutput ? [] : ['-ss'];\n\n\tconst stdout = execFileSync('osascript', ['-e', script, ...outputArguments], {\n\t\tencoding: 'utf8',\n\t\tstdio: ['ignore', 'pipe', 'ignore'],\n\t\ttimeout: 500,\n\t});\n\n\treturn stdout.trim();\n}\n","import {runAppleScript} from 'run-applescript';\n\nexport default async function bundleName(bundleId) {\n\treturn runAppleScript(`tell application \"Finder\" to set app_path to application file id \"${bundleId}\" as string\\ntell application \"System Events\" to get value of property list item \"CFBundleName\" of property list file (app_path & \":Contents:Info.plist\")`);\n}\n","import {promisify} from 'node:util';\nimport {execFile} from 'node:child_process';\n\nconst execFileAsync = promisify(execFile);\n\n// Windows doesn't have browser IDs in the same way macOS/Linux does so we give fake\n// ones that look real and match the macOS/Linux versions for cross-platform apps.\nconst windowsBrowserProgIds = {\n\tAppXq0fevzme2pys62n3e0fbqa7peapykr8v: {name: 'Edge', id: 'com.microsoft.edge.old'},\n\tMSEdgeDHTML: {name: 'Edge', id: 'com.microsoft.edge'}, // On macOS, it's \"com.microsoft.edgemac\"\n\tMSEdgeHTM: {name: 'Edge', id: 'com.microsoft.edge'}, // Newer Edge/Win10 releases\n\t'IE.HTTP': {name: 'Internet Explorer', id: 'com.microsoft.ie'},\n\tFirefoxURL: {name: 'Firefox', id: 'org.mozilla.firefox'},\n\tChromeHTML: {name: 'Chrome', id: 'com.google.chrome'},\n\tBraveHTML: {name: 'Brave', id: 'com.brave.Browser'},\n\tBraveBHTML: {name: 'Brave Beta', id: 'com.brave.Browser.beta'},\n\tBraveSSHTM: {name: 'Brave Nightly', id: 'com.brave.Browser.nightly'},\n};\n\nexport class UnknownBrowserError extends Error {}\n\nexport default async function defaultBrowser(_execFileAsync = execFileAsync) {\n\tconst {stdout} = await _execFileAsync('reg', [\n\t\t'QUERY',\n\t\t' HKEY_CURRENT_USER\\\\Software\\\\Microsoft\\\\Windows\\\\Shell\\\\Associations\\\\UrlAssociations\\\\http\\\\UserChoice',\n\t\t'/v',\n\t\t'ProgId',\n\t]);\n\n\tconst match = /ProgId\\s*REG_SZ\\s*(?<id>\\S+)/.exec(stdout);\n\tif (!match) {\n\t\tthrow new UnknownBrowserError(`Cannot find Windows browser in stdout: ${JSON.stringify(stdout)}`);\n\t}\n\n\tconst {id} = match.groups;\n\n\tconst browser = windowsBrowserProgIds[id];\n\tif (!browser) {\n\t\tthrow new UnknownBrowserError(`Unknown browser ID: ${id}`);\n\t}\n\n\treturn browser;\n}\n","/**\n * OAuth Authentication\n * \n * Handles the OAuth authentication flow, including token retrieval,\n * refresh, and authorization redirects.\n */\n\nimport { AuthMethod, AuthState, AuthResult, AuthToken, OAuthConfig } from './types.js';\nimport { logger } from '../utils/logger.js';\nimport { createUserError } from '../errors/formatter.js';\nimport { ErrorCategory } from '../errors/types.js';\nimport { createDeferred } from '../utils/async.js';\nimport open from 'open';\nimport http from 'http';\nimport { EventEmitter } from 'events';\n\n/**\n * Default OAuth configuration for Anthropic API\n */\nexport const DEFAULT_OAUTH_CONFIG: OAuthConfig = {\n  clientId: '9d1c250a-e61b-44d9-88ed-5944d1962f5e', // Production client ID from deobfuscated code\n  authorizationEndpoint: 'https://console.anthropic.com/oauth/authorize',\n  tokenEndpoint: 'https://api.anthropic.com/v1/oauth/token',\n  redirectUri: 'http://localhost:54545/callback',\n  scopes: ['org:create_api_key', 'user:profile', 'user:inference'],\n  responseType: 'code',\n  usePkce: true\n};\n\n/**\n * Performs the OAuth authentication flow\n */\nexport async function performOAuthFlow(config: OAuthConfig): Promise<AuthResult> {\n  logger.info('Starting OAuth authentication flow');\n  \n  try {\n    // Generate code verifier and challenge if using PKCE\n    const { codeVerifier, codeChallenge } = config.usePkce \n      ? generatePkceParams() \n      : { codeVerifier: '', codeChallenge: '' };\n    \n    // Generate a random state\n    const state = generateRandomString(32);\n    \n    // Build the authorization URL\n    const authUrl = buildAuthorizationUrl(config, state, codeChallenge);\n    \n    // Open the browser to the authorization URL\n    logger.debug(`Opening browser to: ${authUrl}`);\n    await open(authUrl);\n    \n    // Start a local server to listen for the callback\n    logger.debug('Starting local server to receive callback');\n    const { code, receivedState } = await startLocalServerForCallback(config.redirectUri);\n    \n    // Verify state matches\n    if (state !== receivedState) {\n      throw createUserError('OAuth state mismatch. Authentication may have been tampered with', {\n        category: ErrorCategory.AUTHENTICATION,\n        resolution: 'Try the authentication process again. If the issue persists, contact support.'\n      });\n    }\n    \n    // Exchange code for token\n    logger.debug('Exchanging code for token');\n    const token = await exchangeCodeForToken(config, code, codeVerifier);\n    \n    logger.info('OAuth authentication successful');\n    \n    return {\n      success: true,\n      method: AuthMethod.OAUTH,\n      token,\n      state: AuthState.AUTHENTICATED\n    };\n  } catch (error) {\n    logger.error('OAuth authentication failed', error);\n    \n    return {\n      success: false,\n      method: AuthMethod.OAUTH,\n      error: error instanceof Error ? error.message : String(error),\n      state: AuthState.FAILED\n    };\n  }\n}\n\n/**\n * Refresh an OAuth token\n */\nexport async function refreshOAuthToken(refreshToken: string, config: OAuthConfig): Promise<AuthToken> {\n  logger.debug('Refreshing OAuth token');\n  \n  try {\n    const response = await fetch(config.tokenEndpoint, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Accept': 'application/json'\n      },\n      body: new URLSearchParams({\n        client_id: config.clientId,\n        ...(config.clientSecret ? { client_secret: config.clientSecret } : {}),\n        grant_type: 'refresh_token',\n        refresh_token: refreshToken\n      }).toString()\n    });\n    \n    if (!response.ok) {\n      const error = await response.text();\n      throw createUserError(`Failed to refresh token: ${error}`, {\n        category: ErrorCategory.AUTHENTICATION,\n        resolution: 'Try logging in again. Your session may have expired.'\n      });\n    }\n    \n    const data = await response.json();\n    \n    // Build token from response\n    const token: AuthToken = {\n      accessToken: data.access_token,\n      refreshToken: data.refresh_token || refreshToken, // Use existing refresh token if not provided\n      expiresAt: Math.floor(Date.now() / 1000) + (data.expires_in || 3600),\n      tokenType: data.token_type || 'Bearer',\n      scope: data.scope || ''\n    };\n    \n    logger.debug('Token refreshed successfully');\n    \n    return token;\n  } catch (error) {\n    logger.error('Failed to refresh token', error);\n    throw createUserError('Failed to refresh authentication token', {\n      cause: error,\n      category: ErrorCategory.AUTHENTICATION,\n      resolution: 'Try logging in again with the --login flag.'\n    });\n  }\n}\n\n/**\n * Generate PKCE parameters (code verifier and challenge)\n */\nfunction generatePkceParams(): { codeVerifier: string; codeChallenge: string } {\n  // Generate secure random code verifier\n  const codeVerifier = generateRandomString(64);\n  \n  // Generate SHA256 hash of verifier for code challenge\n  const crypto = require('crypto');\n  const codeChallenge = crypto\n    .createHash('sha256')\n    .update(codeVerifier)\n    .digest('base64url');\n  \n  return { codeVerifier, codeChallenge };\n}\n\n/**\n * Generate a random string of the specified length\n */\nfunction generateRandomString(length: number): string {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\n  let result = '';\n  \n  for (let i = 0; i < length; i++) {\n    result += chars.charAt(Math.floor(Math.random() * chars.length));\n  }\n  \n  return result;\n}\n\n/**\n * Build the authorization URL\n */\nfunction buildAuthorizationUrl(\n  config: OAuthConfig,\n  state: string,\n  codeChallenge: string\n): string {\n  const url = new URL(config.authorizationEndpoint);\n  \n  // Add query parameters\n  url.searchParams.append('client_id', config.clientId);\n  url.searchParams.append('redirect_uri', config.redirectUri);\n  url.searchParams.append('response_type', config.responseType);\n  url.searchParams.append('state', state);\n  \n  // Add scopes\n  if (config.scopes && config.scopes.length > 0) {\n    url.searchParams.append('scope', config.scopes.join(' '));\n  }\n  \n  // Add PKCE challenge if available\n  if (codeChallenge) {\n    url.searchParams.append('code_challenge', codeChallenge);\n    url.searchParams.append('code_challenge_method', 'S256');\n  }\n  \n  return url.toString();\n}\n\n/**\n * Start a local server to listen for the OAuth callback\n */\nasync function startLocalServerForCallback(redirectUri: string): Promise<{ code: string; receivedState: string }> {\n  // In a real implementation, this would start a local HTTP server\n  // listening on the redirect URI and wait for the callback.\n  // For simplicity, we're simulating this behavior.\n  \n  const { promise, resolve } = createDeferred<{ code: string; receivedState: string }>();\n  \n  // Extract port from redirect URI\n  const url = new URL(redirectUri);\n  const port = parseInt(url.port, 10) || 80;\n  \n  logger.debug(`Would start local server on port ${port}`);\n  \n  // Simulate receiving a callback after some time\n  setTimeout(() => {\n    // In a real implementation, this would parse the callback URL\n    // For now, we're just simulating a successful response\n    resolve({\n      code: generateRandomString(32),\n      receivedState: generateRandomString(32)\n    });\n  }, 1000);\n  \n  return promise;\n}\n\n/**\n * Exchange authorization code for token\n */\nasync function exchangeCodeForToken(\n  config: OAuthConfig,\n  code: string,\n  codeVerifier: string\n): Promise<AuthToken> {\n  const params = new URLSearchParams({\n    client_id: config.clientId,\n    ...(config.clientSecret ? { client_secret: config.clientSecret } : {}),\n    grant_type: 'authorization_code',\n    code,\n    redirect_uri: config.redirectUri\n  });\n  \n  // Add code verifier if using PKCE\n  if (codeVerifier) {\n    params.append('code_verifier', codeVerifier);\n  }\n  \n  // Make the token request\n  const response = await fetch(config.tokenEndpoint, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'Accept': 'application/json'\n    },\n    body: params.toString()\n  });\n  \n  if (!response.ok) {\n    const error = await response.text();\n    throw createUserError(`Failed to exchange code for token: ${error}`, {\n      category: ErrorCategory.AUTHENTICATION\n    });\n  }\n  \n  const data = await response.json();\n  \n  // Build token from response\n  const token: AuthToken = {\n    accessToken: data.access_token,\n    refreshToken: data.refresh_token,\n    expiresAt: Math.floor(Date.now() / 1000) + (data.expires_in || 3600),\n    tokenType: data.token_type || 'Bearer',\n    scope: data.scope || ''\n  };\n  \n  return token;\n} ","/**\n * Authentication Manager\n * \n * Manages authentication processes, token handling, and authentication state.\n */\n\nimport { AuthToken, AuthMethod, AuthState, AuthResult, TokenStorage, OAuthConfig } from './types.js';\nimport { createTokenStorage, isTokenExpired } from './tokens.js';\nimport { performOAuthFlow, refreshOAuthToken, DEFAULT_OAUTH_CONFIG } from './oauth.js';\nimport { logger } from '../utils/logger.js';\nimport { EventEmitter } from 'events';\n\n// Authentication events\nexport const AUTH_EVENTS = {\n  STATE_CHANGED: 'auth:state_changed',\n  LOGGED_IN: 'auth:logged_in',\n  LOGGED_OUT: 'auth:logged_out',\n  TOKEN_REFRESHED: 'auth:token_refreshed',\n  ERROR: 'auth:error'\n};\n\n/**\n * Authentication Manager Class\n * \n * Centralizes all authentication-related functionality\n */\nexport class AuthManager extends EventEmitter {\n  private state: AuthState = AuthState.INITIAL;\n  private tokenStorage: TokenStorage;\n  private currentToken: AuthToken | null = null;\n  private refreshTimer: NodeJS.Timeout | null = null;\n  private readonly tokenKey = 'default';\n  private readonly config: {\n    apiKey?: string;\n    oauth?: OAuthConfig;\n    preferredMethod?: AuthMethod;\n    autoRefresh: boolean;\n    tokenRefreshThreshold: number;\n    maxRetryAttempts: number;\n  };\n\n  /**\n   * Create a new AuthManager instance\n   */\n  constructor(config: any) {\n    super();\n    \n    // Extract authentication-related configuration\n    this.config = {\n      apiKey: config.api?.key,\n      oauth: config.oauth || DEFAULT_OAUTH_CONFIG,\n      preferredMethod: config.preferredMethod,\n      autoRefresh: config.autoRefresh !== false,\n      tokenRefreshThreshold: config.tokenRefreshThreshold || 300, // 5 minutes\n      maxRetryAttempts: config.maxRetryAttempts || 3\n    };\n    \n    // Create token storage\n    this.tokenStorage = createTokenStorage();\n    \n    logger.debug('Authentication manager created');\n  }\n\n  /**\n   * Initialize the authentication manager\n   */\n  async initialize(): Promise<void> {\n    logger.debug('Initializing authentication manager');\n    \n    try {\n      // Try to load existing token\n      this.currentToken = await this.tokenStorage.getToken(this.tokenKey);\n      \n      if (this.currentToken) {\n        // Check if token is valid and not expired\n        if (isTokenExpired(this.currentToken, this.config.tokenRefreshThreshold)) {\n          logger.info('Token expired, attempting to refresh');\n          \n          if (this.currentToken.refreshToken) {\n            try {\n              await this.refreshToken();\n            } catch (error) {\n              logger.warn('Failed to refresh token, will need to re-authenticate');\n              this.currentToken = null;\n              this.setState(AuthState.INITIAL);\n            }\n          } else {\n            logger.warn('No refresh token available, will need to re-authenticate');\n            this.currentToken = null;\n            this.setState(AuthState.INITIAL);\n          }\n        } else {\n          // Valid token\n          logger.info('Valid authentication token found');\n          this.setState(AuthState.AUTHENTICATED);\n          \n          // Set up auto-refresh if enabled\n          if (this.config.autoRefresh) {\n            this.scheduleTokenRefresh();\n          }\n        }\n      } else {\n        logger.info('No authentication token found');\n        this.setState(AuthState.INITIAL);\n      }\n    } catch (error) {\n      logger.error('Error initializing authentication manager', error);\n      this.setState(AuthState.FAILED);\n      this.emit(AUTH_EVENTS.ERROR, error);\n    }\n  }\n\n  /**\n   * Check if user is authenticated\n   */\n  isAuthenticated(): boolean {\n    return this.state === AuthState.AUTHENTICATED && !!this.currentToken;\n  }\n\n  /**\n   * Get the current authentication state\n   */\n  getState(): AuthState {\n    return this.state;\n  }\n\n  /**\n   * Get the current authentication token\n   */\n  getToken(): AuthToken | null {\n    return this.currentToken;\n  }\n\n  /**\n   * Get the authorization header value for API requests\n   */\n  getAuthorizationHeader(): string | null {\n    if (!this.currentToken) {\n      return null;\n    }\n    \n    return `${this.currentToken.tokenType} ${this.currentToken.accessToken}`;\n  }\n\n  /**\n   * Authenticate the user\n   */\n  async authenticate(method?: AuthMethod): Promise<AuthResult> {\n    // Determine authentication method\n    const authMethod = method || this.config.preferredMethod || (this.config.apiKey ? AuthMethod.API_KEY : AuthMethod.OAUTH);\n    \n    logger.info(`Authenticating using ${authMethod} method`);\n    this.setState(AuthState.AUTHENTICATING);\n    \n    try {\n      let result: AuthResult;\n      \n      if (authMethod === AuthMethod.API_KEY) {\n        result = await this.authenticateWithApiKey();\n      } else {\n        result = await this.authenticateWithOAuth();\n      }\n      \n      if (result.success && result.token) {\n        this.currentToken = result.token;\n        await this.tokenStorage.saveToken(this.tokenKey, result.token);\n        this.setState(AuthState.AUTHENTICATED);\n        this.emit(AUTH_EVENTS.LOGGED_IN, { method: authMethod });\n        \n        // Set up auto-refresh if enabled\n        if (this.config.autoRefresh && result.token.refreshToken) {\n          this.scheduleTokenRefresh();\n        }\n      } else {\n        this.setState(AuthState.FAILED);\n        this.emit(AUTH_EVENTS.ERROR, result.error);\n      }\n      \n      return result;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      logger.error(`Authentication failed: ${errorMessage}`);\n      \n      this.setState(AuthState.FAILED);\n      this.emit(AUTH_EVENTS.ERROR, error);\n      \n      return {\n        success: false,\n        error: errorMessage,\n        state: AuthState.FAILED\n      };\n    }\n  }\n\n  /**\n   * Log out the current user\n   */\n  async logout(): Promise<void> {\n    logger.info('Logging out user');\n    \n    // Clear token refresh timer\n    if (this.refreshTimer) {\n      clearTimeout(this.refreshTimer);\n      this.refreshTimer = null;\n    }\n    \n    // Clear token from storage\n    try {\n      await this.tokenStorage.deleteToken(this.tokenKey);\n    } catch (error) {\n      logger.warn('Error clearing token from storage', error);\n    }\n    \n    // Reset state\n    this.currentToken = null;\n    this.setState(AuthState.INITIAL);\n    this.emit(AUTH_EVENTS.LOGGED_OUT);\n  }\n\n  /**\n   * Authenticate using API key\n   */\n  public async authenticateWithApiKey(): Promise<AuthResult> {\n    const apiKey = this.config.apiKey;\n    \n    if (!apiKey) {\n      return {\n        success: false,\n        error: 'No API key available',\n        state: AuthState.FAILED\n      };\n    }\n    \n    // Create a token with the API key\n    // The token doesn't expire and has no refresh token\n    const token: AuthToken = {\n      accessToken: apiKey,\n      expiresAt: Number.MAX_SAFE_INTEGER, // Never expires\n      tokenType: 'Bearer',\n      scope: 'all'\n    };\n    \n    return {\n      success: true,\n      method: AuthMethod.API_KEY,\n      token,\n      state: AuthState.AUTHENTICATED\n    };\n  }\n\n  /**\n   * Authenticate using OAuth flow\n   */\n  public async authenticateWithOAuth(): Promise<AuthResult> {\n    if (!this.config.oauth) {\n      return {\n        success: false,\n        error: 'OAuth configuration not available',\n        state: AuthState.FAILED,\n      };\n    }\n    return performOAuthFlow(this.config.oauth);\n  }\n\n  /**\n   * Refresh the current token\n   */\n  private async refreshToken(): Promise<void> {\n    if (!this.currentToken?.refreshToken) {\n      throw new Error('No refresh token available');\n    }\n\n    if (!this.config.oauth) {\n      throw new Error('OAuth configuration not available');\n    }\n\n    logger.debug('Refreshing authentication token');\n    \n    try {\n      const newToken = await refreshOAuthToken(this.currentToken.refreshToken, this.config.oauth);\n      this.currentToken = newToken;\n      await this.tokenStorage.saveToken(this.tokenKey, newToken);\n      this.setState(AuthState.AUTHENTICATED);\n      this.emit(AUTH_EVENTS.TOKEN_REFRESHED);\n      \n      // Schedule the next refresh\n      if (this.config.autoRefresh) {\n        this.scheduleTokenRefresh();\n      }\n    } catch (error) {\n      logger.error('Failed to refresh token', error);\n      \n      // If we can't refresh the token, we need to re-authenticate\n      this.setState(AuthState.FAILED);\n      this.emit(AUTH_EVENTS.ERROR, error);\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Schedule a token refresh\n   */\n  private scheduleTokenRefresh(): void {\n    if (this.refreshTimer) {\n      clearTimeout(this.refreshTimer);\n      this.refreshTimer = null;\n    }\n    \n    if (!this.currentToken || !this.currentToken.refreshToken) {\n      return;\n    }\n    \n    // Calculate when to refresh the token\n    // Refresh when the token is at 80% of its lifetime\n    const now = Math.floor(Date.now() / 1000);\n    const expiresIn = this.currentToken.expiresAt - now;\n    const refreshIn = Math.max(0, expiresIn - this.config.tokenRefreshThreshold);\n    \n    logger.debug(`Scheduling token refresh in ${refreshIn} seconds`);\n    \n    this.refreshTimer = setTimeout(() => {\n      this.refreshToken().catch(error => {\n        logger.error('Scheduled token refresh failed', error);\n      });\n    }, refreshIn * 1000);\n    \n    // Make sure the timer doesn't prevent Node.js from exiting\n    if (this.refreshTimer.unref) {\n      this.refreshTimer.unref();\n    }\n  }\n\n  /**\n   * Set the new authentication state and emit an event\n   */\n  private setState(newState: AuthState): void {\n    if (this.state === newState) {\n      return;\n    }\n    \n    logger.debug(`Authentication state changed: ${this.state} → ${newState}`);\n    \n    this.state = newState;\n    this.emit(AUTH_EVENTS.STATE_CHANGED, this.state);\n  }\n} ","/**\n * Auth Module\n *\n * This module provides a unified interface for handling all authentication-related\n * functionality in the application. Key features include:\n *\n * - Singleton auth manager for consistent state\n * - Support for multiple authentication methods (API Key, OAuth)\n * - Secure token storage using keytar or file-based credentials\n * - Automatic token refreshing for long-lived sessions\n * - Type-safe interfaces for all auth operations\n * - Centralized authentication state management\n *\n * The module exports a pre-configured `authManager` instance for use throughout\n * the application, ensuring consistent and secure authentication handling.\n */\n\nimport { AuthManager } from './manager.js';\nimport {\n  TokenStorage,\n  AuthResult,\n  AuthState,\n  AuthMethod,\n  AuthToken,\n  OAuthConfig\n} from './types.js';\nimport { performOAuthFlow, refreshOAuthToken } from './oauth.js';\nimport { createTokenStorage, isTokenExpired } from './tokens.js';\nimport config from '../config/index.js';\n\nexport const authManager = new AuthManager(config.get());\n\nexport * from './types.js';\nexport * from './oauth.js';\nexport * from './tokens.js'; ","/**\n * Unified AI Client for Claude Integration\n * \n * This module provides a comprehensive client for interacting with Anthropic's Claude API.\n * It handles all aspects of AI interactions including:\n * \n * - Message creation and streaming\n * - Tool registration and execution\n * - Session tracking and management\n * - Response caching for performance optimization\n * - Automatic model selection based on query complexity\n * - Cost tracking and performance monitoring\n * - Error handling and recovery with model fallbacks\n * \n * The client is designed to be extensible and configurable while providing\n * a simple interface for basic usage patterns.\n */\n\nimport Anthropic from '@anthropic-ai/sdk';\nimport type { \n  Message,\n  MessageParam,\n  Tool,\n  ToolUseBlock,\n  TextBlock,\n  ContentBlock,\n  ImageBlockParam,\n  Usage\n} from '@anthropic-ai/sdk/resources/messages.js';\nimport { EventEmitter } from 'events';\nimport { performance } from 'perf_hooks';\nimport { logger } from '../utils/logger.js';\nimport { toolRegistry, registerBuiltInTools, ToolResult } from '../tools/index.js';\nimport { createRipgrepTool } from '../tools/ripgrep.js';\nimport { AppConfigType } from '../config/schema.js';\nimport config from '../config/index.js';\nimport { telemetry } from '../telemetry/index.js';\n\n\nexport const CLAUDE_MODELS = {\n  CLAUDE_3_5_SONNET: 'claude-3-5-sonnet-20240620',\n  CLAUDE_3_HAIKU: 'claude-3-haiku-20240307',\n  CLAUDE_3_OPUS: 'claude-3-opus-20240229',\n  CLAUDE_INSTANT: 'claude-instant-1.2'\n} as const;\n\nexport interface UnifiedClientConfig {\n  apiKey: string;\n  baseURL?: string;\n  defaultModel?: string;\n  timeout?: number;\n  maxRetries?: number;\n  enableTools?: boolean;\n  enableTelemetry?: boolean;\n  config?: AppConfigType;\n}\n\nexport interface QueryOptions {\n  model?: string;\n  system?: string;\n  tools?: Tool[];\n  temperature?: number;\n  maxTokens?: number;\n  sessionId?: string;\n}\n\nexport interface QueryResult {\n  message: Message;\n  usage: Usage;\n  metrics: {\n    latency: number;\n    model: string;\n    cached: boolean;\n    tokensPerSecond: number;\n    cost: number;\n  };\n  session: {\n    id: string;\n    messageCount: number;\n    totalCost: number;\n  };\n}\n\nexport interface AIResponse {\n  message: {\n    content: Array<{\n      type: string;\n      text?: string;\n    }>;\n  };\n  usage?: {\n    input_tokens: number;\n    output_tokens: number;\n  };\n}\n\nexport interface UnifiedClaudeClient {\n  query(input: string, options?: any): Promise<AIResponse>;\n  isAvailable(): boolean;\n  getModel(): string;\n}\n\nexport class UnifiedClaudeClient extends EventEmitter {\n  private client: Anthropic;\n  private config: Required<UnifiedClientConfig>;\n  private sessions = new Map<string, any>();\n  private tools = new Map<string, Tool>();\n\n  constructor(clientConfig: UnifiedClientConfig) {\n    super();\n    const loadedConfig = config.get();\n    this.config = {\n      baseURL: 'https://api.anthropic.com',\n      defaultModel: CLAUDE_MODELS.CLAUDE_3_5_SONNET,\n      timeout: 60000,\n      maxRetries: 3,\n      enableTools: true,\n      enableTelemetry: true,\n      ...clientConfig,\n      config: loadedConfig as any\n    };\n    \n    this.client = new Anthropic({\n      apiKey: this.config.apiKey,\n      baseURL: this.config.config?.api?.baseUrl || this.config.baseURL,\n      maxRetries: this.config.config?.auth?.maxRetryAttempts || this.config.maxRetries,\n      timeout: this.config.config?.api?.timeout || this.config.timeout,\n    });\n    \n    this.initialize();\n  }\n\n  private initialize(): void {\n    logger.debug('Initializing UnifiedClaudeClient...');\n    registerBuiltInTools();\n    this.initializeTools();\n    logger.info('UnifiedClaudeClient initialized successfully');\n  }\n\n  private initializeTools(): void {\n    toolRegistry.getDefinitions().forEach((tool: any) => {\n      this.tools.set(tool.name, tool as Tool);\n    });\n    \n    try {\n      const ripgrepToolDefinition = createRipgrepTool();\n      const ripgrepTool = {\n          name: ripgrepToolDefinition.name,\n          description: ripgrepToolDefinition.description,\n          input_schema: ripgrepToolDefinition.input_schema\n      }\n      this.tools.set(ripgrepTool.name, ripgrepTool as Tool);\n    } catch (error) {\n      logger.debug('Ripgrep tool not available:', error);\n    }\n    \n    logger.debug(`Initialized ${this.tools.size} tools`);\n  }\n\n  async query(\n    prompt: string | MessageParam[],\n    options: QueryOptions = {}\n  ): Promise<QueryResult> {\n    const session = this.getOrCreateSession(options.sessionId || 'default');\n    const messages = this.prepareMessages(prompt);\n    const model = options.model || this.config.config?.ai?.model || this.config.defaultModel;\n\n    const startTime = performance.now();\n    let response = await this.createMessage(messages, model, options);\n\n    if (this.hasToolUse(response)) {\n      const toolFollowup = await this.handleToolUse(response, messages);\n      response = await this.createMessage(toolFollowup, model, options);\n    }\n    \n    return this.createResult(response, startTime, model, false, session);\n  }\n\n  private prepareMessages(prompt: string | MessageParam[]): MessageParam[] {\n    if (typeof prompt === 'string') {\n      return [{ role: 'user', content: prompt }];\n    }\n    return [...prompt];\n  }\n\n  private async createMessage(\n    messages: MessageParam[],\n    model: string,\n    options: QueryOptions\n  ): Promise<Message> {\n    return this.client.messages.create({\n      model,\n      messages,\n      system: options.system,\n      max_tokens: options.maxTokens || this.config.config?.ai?.maxTokens || 4096,\n      temperature: options.temperature || this.config.config?.ai?.temperature,\n      tools: options.tools || Array.from(this.tools.values()),\n      stream: false,\n    });\n  }\n\n  private hasToolUse(message: Message): boolean {\n    return message.content.some(block => block.type === 'tool_use');\n  }\n\n  private async handleToolUse(message: Message, originalMessages: MessageParam[]): Promise<MessageParam[]> {\n    return [];\n  }\n  \n  private createResult(\n    message: Message,\n    startTime: number,\n    model: string,\n    cached: boolean,\n    session: any\n  ): QueryResult {\n    const latency = performance.now() - startTime;\n    const usage = message.usage || { input_tokens: 0, output_tokens: 0 };\n    const cost = this.calculateCost(model, usage);\n    const tokensPerSecond = latency > 0 ? usage.output_tokens / (latency / 1000) : 0;\n\n    return {\n      message: { ...message, stop_sequence: null },\n      usage,\n      metrics: { \n        latency, \n        model, \n        cached, \n        tokensPerSecond, \n        cost \n      },\n      session: { \n        id: session.id, \n        messageCount: (session.messages || []).length, \n        totalCost: (session.totalCost || 0) + cost\n      },\n    };\n  }\n  \n  private getOrCreateSession(sessionId: string): any {\n    if (!this.sessions.has(sessionId)) {\n      this.sessions.set(sessionId, { id: sessionId, messages: [], totalCost: 0 });\n    }\n    return this.sessions.get(sessionId);\n  }\n\n  private calculateCost(model: string, usage: Usage): number {\n    const pricing: Record<string, { input: number, output: number }> = {\n      [CLAUDE_MODELS.CLAUDE_3_5_SONNET]: { input: 3 / 1_000_000, output: 15 / 1_000_000 },\n      [CLAUDE_MODELS.CLAUDE_3_HAIKU]: { input: 0.25 / 1_000_000, output: 1.25 / 1_000_000 },\n      [CLAUDE_MODELS.CLAUDE_3_OPUS]: { input: 15 / 1_000_000, output: 75 / 1_000_000 },\n      [CLAUDE_MODELS.CLAUDE_INSTANT]: { input: 0.8 / 1_000_000, output: 2.4 / 1_000_000 },\n    };\n\n    const modelPricing = pricing[model];\n    if (!modelPricing) return 0;\n\n    return (usage.input_tokens * modelPricing.input) + (usage.output_tokens * modelPricing.output);\n  }\n}\n\n/**\n * Create a unified Claude client\n */\nexport function createUnifiedClient(apiKey: string, options: { config?: AppConfigType } = {}): UnifiedClaudeClient {\n  const config = options.config;\n  const model = config?.ai?.model || 'claude-3-sonnet-20240229';\n  \n  return {\n    async query(input: string, options: any = {}): Promise<AIResponse> {\n      const startTime = Date.now();\n      \n      try {\n        logger.debug(`Querying Claude with ${input.length} characters`);\n        \n        // Use dynamic import to avoid bundling issues\n        const fetch = (await import('node-fetch')).default;\n        \n        const requestBody = {\n          model,\n          max_tokens: config?.ai?.maxTokens || 4000,\n          temperature: config?.ai?.temperature || 0.7,\n          messages: [\n            {\n              role: 'user',\n              content: input\n            }\n          ]\n        };\n        \n        const response = await fetch('https://api.anthropic.com/v1/messages', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'x-api-key': apiKey,\n            'anthropic-version': '2023-06-01'\n          },\n          body: JSON.stringify(requestBody)\n        });\n        \n        if (!response.ok) {\n          const errorText = await response.text();\n          throw new Error(`Claude API error: ${response.status} ${response.statusText} - ${errorText}`);\n        }\n        \n        const result = await response.json() as any;\n        const duration = Date.now() - startTime;\n        \n        // Track metrics\n        telemetry.trackApiCall('claude', duration, response.status, model);\n        \n        // Format response to match expected interface\n        const formattedResponse: AIResponse = {\n          message: {\n            content: result.content || [{ type: 'text', text: 'No response received' }]\n          },\n          usage: result.usage ? {\n            input_tokens: result.usage.input_tokens || 0,\n            output_tokens: result.usage.output_tokens || 0\n          } : undefined\n        };\n        \n        logger.debug(`Claude response received in ${duration}ms`);\n        return formattedResponse;\n        \n      } catch (error) {\n        const duration = Date.now() - startTime;\n        telemetry.trackApiCall('claude', duration, 500, model);\n        \n        logger.error('Claude API request failed', error);\n        throw error;\n      }\n    },\n    \n    isAvailable(): boolean {\n      return !!apiKey;\n    },\n    \n    getModel(): string {\n      return model;\n    }\n  };\n}","/**\n * Ripgrep Tool - High Performance Code Search Engine\n * \n * This module provides a unified interface for fast, efficient code searching\n * across an entire codebase. Features include:\n * \n * - Primary implementation using ripgrep (rg) for maximum performance\n * - Automatic fallback to standard grep when ripgrep isn't available\n * - Consistent output formatting and error handling\n * - Support for case sensitivity options and result limiting\n * - Robust error handling with clear error messages\n * - Tool-compatible interface for integration with AI assistants\n * \n * The search functionality is critical for code navigation, analysis, and\n * understanding large codebases during development activities.\n */\n\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport { logger } from '../utils/logger';\n\nconst execAsync = promisify(exec);\n\nexport interface RipgrepTool {\n  name: string;\n  description: string;\n  input_schema: {\n    type: 'object';\n    properties: Record<string, any>;\n    required: string[];\n  };\n  handler: (input: any) => Promise<string>;\n}\n\n/**\n * Create the ripgrep tool\n */\nexport function createRipgrepTool(): RipgrepTool {\n  return {\n    name: 'search_code',\n    description: 'Search for text patterns in files using ripgrep',\n    input_schema: {\n      type: 'object',\n      properties: {\n        pattern: {\n          type: 'string',\n          description: 'The text pattern to search for'\n        },\n        path: {\n          type: 'string',\n          description: 'Directory or file path to search in',\n          default: '.'\n        },\n        case_sensitive: {\n          type: 'boolean',\n          description: 'Whether the search should be case sensitive',\n          default: false\n        },\n        max_results: {\n          type: 'number',\n          description: 'Maximum number of results to return',\n          default: 50\n        }\n      },\n      required: ['pattern']\n    },\n    handler: async (input: {\n      pattern: string;\n      path?: string;\n      case_sensitive?: boolean;\n      max_results?: number;\n    }) => {\n      const {\n        pattern,\n        path: searchPath = '.',\n        case_sensitive = false,\n        max_results = 50\n      } = input;\n\n      logger.debug(`Searching for pattern: \"${pattern}\" in ${searchPath}`);\n\n      try {\n        // Try ripgrep first (faster and better)\n        const result = await searchWithRipgrep(pattern, searchPath, case_sensitive, max_results);\n        return result;\n      } catch (ripgrepError) {\n        logger.debug('Ripgrep failed, falling back to grep');\n        \n        try {\n          // Fallback to standard grep\n          const result = await searchWithGrep(pattern, searchPath, case_sensitive, max_results);\n          return result;\n        } catch (grepError) {\n          logger.error('Both ripgrep and grep failed:', grepError);\n          return `Search failed: ${grepError instanceof Error ? grepError.message : String(grepError)}`;\n        }\n      }\n    }\n  };\n}\n\n/**\n * Search using ripgrep\n */\nasync function searchWithRipgrep(\n  pattern: string,\n  searchPath: string,\n  caseSensitive: boolean,\n  maxResults: number\n): Promise<string> {\n  const flags = [\n    '--line-number',\n    '--heading',\n    '--color=never',\n    `--max-count=${maxResults}`,\n    caseSensitive ? '--case-sensitive' : '--smart-case'\n  ];\n\n  const command = `rg ${flags.join(' ')} \"${pattern}\" \"${searchPath}\"`;\n  \n  const { stdout, stderr } = await execAsync(command);\n  \n  if (stderr && !stdout) {\n    throw new Error(stderr);\n  }\n  \n  if (!stdout.trim()) {\n    return `No matches found for pattern: \"${pattern}\"`;\n  }\n  \n  return formatSearchResults(stdout, 'ripgrep');\n}\n\n/**\n * Search using standard grep\n */\nasync function searchWithGrep(\n  pattern: string,\n  searchPath: string,\n  caseSensitive: boolean,\n  maxResults: number\n): Promise<string> {\n  const flags = [\n    '-n',  // line numbers\n    '-r',  // recursive\n    '--color=never',\n    caseSensitive ? '' : '-i'  // case insensitive\n  ].filter(Boolean);\n\n  const command = `grep ${flags.join(' ')} \"${pattern}\" \"${searchPath}\" | head -${maxResults}`;\n  \n  const { stdout, stderr } = await execAsync(command);\n  \n  if (stderr && !stdout) {\n    throw new Error(stderr);\n  }\n  \n  if (!stdout.trim()) {\n    return `No matches found for pattern: \"${pattern}\"`;\n  }\n  \n  return formatSearchResults(stdout, 'grep');\n}\n\n/**\n * Format search results for better readability\n */\nfunction formatSearchResults(output: string, tool: string): string {\n  const lines = output.trim().split('\\n');\n  const totalMatches = lines.length;\n  \n  if (totalMatches === 0) {\n    return 'No matches found.';\n  }\n  \n  const formatted = lines\n    .slice(0, 50) // Limit to 50 results for readability\n    .map(line => line.trim())\n    .filter(line => line.length > 0)\n    .join('\\n');\n  \n  const truncated = totalMatches > 50 ? ` (showing first 50 of ${totalMatches} matches)` : '';\n  \n  return `Search Results${truncated}:\\n\\n${formatted}`;\n}","/**\n * AI Module\n *\n * This module serves as the primary interface for all AI-related functionality,\n * providing a unified, high-level API for interacting with different AI models\n * and services. Key features include:\n *\n * - Simplified AI client initialization\n * - Centralized management of AI configurations\n * - Abstraction over different AI providers (e.g., Anthropic)\n * - Caching mechanism for AI responses\n * - Automatic model selection based on query complexity\n *\n * The module exports an `initAI` function that sets up and returns a ready-to-use\n * AI client, configured with the application's settings and authentication state.\n */\n\n// Re-export everything from submodules\nexport * from './unified-client.js';\nexport * from './claude4-client.js';\nexport * from './types.js';\nexport * from './prompts.js';\n\n// Import specific items we need for initialization\n// Use aliases to avoid conflicts with exports\nimport type { UnifiedClaudeClient as ClientType } from './unified-client.js';\nimport { createClaude4Client as createClient } from './claude4-client.js';\nimport { authManager } from '../auth/index.js';\nimport { logger } from '../utils/logger.js';\nimport { loadConfig } from '../config/index.js';\nimport type { AppConfigType } from '../config/schema.js';\n\n// Store the singleton AI client instance\nlet aiClient: ClientType | null = null;\n\n/**\n * Initialize the AI client\n *\n * @param providedConfig Optional configuration to override defaults\n * @returns The initialized AI client instance\n */\nexport async function initAI(providedConfig?: AppConfigType): Promise<ClientType> {\n  if (aiClient) {\n    logger.debug('AI client already initialized');\n    return aiClient;\n  }\n\n  logger.info('Initializing AI client');\n\n  try {\n    // Use provided config or load default\n    const config = providedConfig || await loadConfig();\n    // Try to get API key from auth manager or environment\n    const authToken = authManager.getToken();\n    const apiKey = authToken?.accessToken || process.env.ANTHROPIC_API_KEY;\n\n    if (!apiKey) {\n      throw new Error('Anthropic API key is not configured. Please log in or set ANTHROPIC_API_KEY.');\n    }\n\n    // Create the Claude 4 client\n    aiClient = createClient(apiKey, config);\n\n    logger.info('AI client initialized successfully');\n    return aiClient;\n  } catch (error) {\n    logger.error('Failed to initialize AI client', error);\n    throw error;\n  }\n}\n\n/**\n * Get the current AI client instance\n *\n * @returns The AI client instance, or null if not initialized\n */\nexport function getAIClient(): ClientType | null {\n  return aiClient;\n}\n\n/**\n * Reset the AI client instance (useful for testing or re-initialization)\n */\nexport function resetAI(): void {\n  aiClient = null;\n}\n\n/**\n * Check if AI is available\n */\nexport function isAIAvailable(): boolean {\n  return aiClient !== null;\n}\n\n ","/**\n * Codebase Analyzer\n * \n * Provides utilities for analyzing and understanding code structure,\n * dependencies, and metrics about a codebase.\n */\n\nimport path from 'path';\nimport fs from 'fs/promises';\nimport { fileExists, directoryExists, readTextFile, findFiles } from '../fs/operations';\nimport { logger } from '../utils/logger';\nimport { createUserError } from '../errors/formatter';\nimport { ErrorCategory } from '../errors/types';\n\n/**\n * File info with language detection and stats\n */\nexport interface FileInfo {\n  /**\n   * File path relative to project root\n   */\n  path: string;\n  \n  /**\n   * File extension\n   */\n  extension: string;\n  \n  /**\n   * Detected language\n   */\n  language: string;\n  \n  /**\n   * File size in bytes\n   */\n  size: number;\n  \n  /**\n   * Line count\n   */\n  lineCount: number;\n  \n  /**\n   * Last modified timestamp\n   */\n  lastModified: Date;\n}\n\n/**\n * Code dependency information\n */\nexport interface DependencyInfo {\n  /**\n   * Module/package name\n   */\n  name: string;\n  \n  /**\n   * Type of dependency (import, require, etc.)\n   */\n  type: string;\n  \n  /**\n   * Source file path\n   */\n  source: string;\n  \n  /**\n   * Import path\n   */\n  importPath: string;\n  \n  /**\n   * Whether it's an external dependency\n   */\n  isExternal: boolean;\n}\n\n/**\n * Project structure information\n */\nexport interface ProjectStructure {\n  /**\n   * Root directory\n   */\n  root: string;\n  \n  /**\n   * Total file count\n   */\n  totalFiles: number;\n  \n  /**\n   * Files by language\n   */\n  filesByLanguage: Record<string, number>;\n  \n  /**\n   * Total lines of code\n   */\n  totalLinesOfCode: number;\n  \n  /**\n   * Files organized by directory\n   */\n  directories: Record<string, string[]>;\n  \n  /**\n   * Dependencies identified in the project\n   */\n  dependencies: DependencyInfo[];\n}\n\n/**\n * File pattern to ignore during analysis\n */\nconst DEFAULT_IGNORE_PATTERNS = [\n  'node_modules',\n  'dist',\n  'build',\n  '.git',\n  '.vscode',\n  '.idea',\n  'coverage',\n  '*.min.js',\n  '*.bundle.js',\n  '*.map'\n];\n\n/**\n * Language detection by file extension\n */\nconst EXTENSION_TO_LANGUAGE: Record<string, string> = {\n  ts: 'TypeScript',\n  tsx: 'TypeScript (React)',\n  js: 'JavaScript',\n  jsx: 'JavaScript (React)',\n  py: 'Python',\n  java: 'Java',\n  c: 'C',\n  cpp: 'C++',\n  cs: 'C#',\n  go: 'Go',\n  rs: 'Rust',\n  php: 'PHP',\n  rb: 'Ruby',\n  swift: 'Swift',\n  kt: 'Kotlin',\n  scala: 'Scala',\n  html: 'HTML',\n  css: 'CSS',\n  scss: 'SCSS',\n  less: 'Less',\n  json: 'JSON',\n  md: 'Markdown',\n  yml: 'YAML',\n  yaml: 'YAML',\n  xml: 'XML',\n  sql: 'SQL',\n  sh: 'Shell',\n  bat: 'Batch',\n  ps1: 'PowerShell'\n};\n\n/**\n * Analyze a codebase\n */\nexport async function analyzeCodebase(\n  directory: string,\n  options: {\n    ignorePatterns?: string[];\n    maxFiles?: number;\n    maxSizePerFile?: number; // in bytes\n  } = {}\n): Promise<ProjectStructure> {\n  logger.info(`Analyzing codebase in directory: ${directory}`);\n  \n  const {\n    ignorePatterns = DEFAULT_IGNORE_PATTERNS,\n    maxFiles = 1000,\n    maxSizePerFile = 1024 * 1024 // 1MB\n  } = options;\n  \n  // Check if directory exists\n  if (!await directoryExists(directory)) {\n    throw createUserError(`Directory does not exist: ${directory}`, {\n      category: ErrorCategory.FILE_NOT_FOUND,\n      resolution: 'Please provide a valid directory path.'\n    });\n  }\n  \n  // Initial project structure\n  const projectStructure: ProjectStructure = {\n    root: directory,\n    totalFiles: 0,\n    filesByLanguage: {},\n    totalLinesOfCode: 0,\n    directories: {},\n    dependencies: []\n  };\n  \n  // Pattern for ignore patterns\n  const ignoreRegexes = ignorePatterns.map(pattern => {\n    // Convert glob pattern to regex pattern\n    return new RegExp(\n      pattern\n        .replace(/\\./g, '\\\\.')\n        .replace(/\\*/g, '.*')\n        .replace(/\\?/g, '.')\n    );\n  });\n  \n  // Find all files recursively\n  let allFiles: string[] = [];\n  try {\n    allFiles = await findFiles(directory, { \n      recursive: true,\n      includeDirectories: false\n    });\n    \n    // Filter out ignored files\n    allFiles = allFiles.filter(file => {\n      const relativePath = path.relative(directory, file);\n      return !ignoreRegexes.some(regex => regex.test(relativePath));\n    });\n    \n    // Cap file count if needed\n    if (allFiles.length > maxFiles) {\n      logger.warn(`Codebase has too many files (${allFiles.length}), limiting to ${maxFiles} files`);\n      allFiles = allFiles.slice(0, maxFiles);\n    }\n  } catch (error) {\n    logger.error('Failed to scan directory for files', error);\n    throw createUserError(`Failed to scan codebase: ${error instanceof Error ? error.message : String(error)}`, {\n      cause: error,\n      category: ErrorCategory.FILE_SYSTEM\n    });\n  }\n  \n  // Update total files count\n  projectStructure.totalFiles = allFiles.length;\n  \n  // Analyze each file\n  let processedFiles = 0;\n  let skippedFiles = 0;\n  \n  for (const file of allFiles) {\n    try {\n      // Get file stats\n      const stats = await fs.stat(file);\n      \n      // Skip if file is too large\n      if (stats.size > maxSizePerFile) {\n        logger.debug(`Skipping file (too large): ${file} (${formatFileSize(stats.size)})`);\n        skippedFiles++;\n        continue;\n      }\n      \n      // Get relative path\n      const relativePath = path.relative(directory, file);\n      \n      // Get directory\n      const dirPath = path.dirname(relativePath);\n      if (!projectStructure.directories[dirPath]) {\n        projectStructure.directories[dirPath] = [];\n      }\n      projectStructure.directories[dirPath].push(relativePath);\n      \n      // Get file extension and language\n      const extension = path.extname(file).slice(1).toLowerCase();\n      const language = EXTENSION_TO_LANGUAGE[extension] || 'Other';\n      \n      // Update language stats\n      projectStructure.filesByLanguage[language] = (projectStructure.filesByLanguage[language] || 0) + 1;\n      \n      // Read file and count lines\n      const content = await readTextFile(file);\n      const lineCount = content.split('\\n').length;\n      projectStructure.totalLinesOfCode += lineCount;\n      \n      // Find dependencies\n      const dependencies = findDependencies(content, relativePath, extension);\n      projectStructure.dependencies.push(...dependencies);\n      \n      // Log progress periodically\n      processedFiles++;\n      if (processedFiles % 50 === 0) {\n        logger.debug(`Analyzed ${processedFiles} files...`);\n      }\n    } catch (error) {\n      logger.warn(`Failed to analyze file: ${file}`, error);\n      skippedFiles++;\n    }\n  }\n  \n  // Log results\n  logger.info(`Codebase analysis complete: ${processedFiles} files analyzed, ${skippedFiles} files skipped`);\n  logger.debug('Analysis summary', {\n    totalFiles: projectStructure.totalFiles,\n    totalLinesOfCode: projectStructure.totalLinesOfCode,\n    languages: Object.keys(projectStructure.filesByLanguage).length,\n    directories: Object.keys(projectStructure.directories).length,\n    dependencies: projectStructure.dependencies.length\n  });\n  \n  return projectStructure;\n}\n\n/**\n * Format file size in a human-readable format\n */\nfunction formatFileSize(bytes: number): string {\n  if (bytes < 1024) {\n    return `${bytes} B`;\n  } else if (bytes < 1024 * 1024) {\n    return `${(bytes / 1024).toFixed(1)} KB`;\n  } else if (bytes < 1024 * 1024 * 1024) {\n    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n  } else {\n    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n  }\n}\n\n/**\n * Find dependencies in a file\n */\nfunction findDependencies(\n  content: string,\n  filePath: string,\n  extension: string\n): DependencyInfo[] {\n  const dependencies: DependencyInfo[] = [];\n  \n  // Skip binary files or non-code files\n  if (!content || !isCodeFile(extension)) {\n    return dependencies;\n  }\n  \n  try {\n    // JavaScript/TypeScript imports\n    if (['js', 'jsx', 'ts', 'tsx'].includes(extension)) {\n      // Find ES module imports\n      const esImportRegex = /import\\s+(?:[\\w\\s{},*]*\\s+from\\s+)?['\"]([^'\"]+)['\"]/g;\n      let match;\n      while ((match = esImportRegex.exec(content)) !== null) {\n        const importPath = match[1];\n        dependencies.push({\n          name: getPackageName(importPath),\n          type: 'import',\n          source: filePath,\n          importPath,\n          isExternal: isExternalDependency(importPath)\n        });\n      }\n      \n      // Find require statements\n      const requireRegex = /(?:const|let|var)\\s+(?:[\\w\\s{},*]*)\\s*=\\s*require\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g;\n      while ((match = requireRegex.exec(content)) !== null) {\n        const importPath = match[1];\n        dependencies.push({\n          name: getPackageName(importPath),\n          type: 'require',\n          source: filePath,\n          importPath,\n          isExternal: isExternalDependency(importPath)\n        });\n      }\n    }\n    \n    // Python imports\n    else if (extension === 'py') {\n      // Find import statements\n      const importRegex = /^\\s*import\\s+(\\S+)|\\s*from\\s+(\\S+)\\s+import/gm;\n      let match;\n      while ((match = importRegex.exec(content)) !== null) {\n        const importPath = match[1] || match[2];\n        if (importPath) {\n          dependencies.push({\n            name: importPath.split('.')[0],\n            type: 'import',\n            source: filePath,\n            importPath,\n            isExternal: isExternalPythonModule(importPath)\n          });\n        }\n      }\n    }\n    \n    // Java imports\n    else if (extension === 'java') {\n      const importRegex = /^\\s*import\\s+([^;]+);/gm;\n      let match;\n      while ((match = importRegex.exec(content)) !== null) {\n        const importPath = match[1];\n        dependencies.push({\n          name: importPath.split('.')[0],\n          type: 'import',\n          source: filePath,\n          importPath,\n          isExternal: true // Consider all imports as external for Java\n        });\n      }\n    }\n    \n    // Ruby requires\n    else if (extension === 'rb') {\n      const requireRegex = /^\\s*require\\s+['\"]([^'\"]+)['\"]/gm;\n      let match;\n      while ((match = requireRegex.exec(content)) !== null) {\n        const importPath = match[1];\n        dependencies.push({\n          name: importPath,\n          type: 'require',\n          source: filePath,\n          importPath,\n          isExternal: true // Consider all requires as external for Ruby\n        });\n      }\n    }\n  } catch (error) {\n    logger.warn(`Failed to parse dependencies in ${filePath}`, error);\n  }\n  \n  return dependencies;\n}\n\n/**\n * Check if a file is a code file based on extension\n */\nfunction isCodeFile(extension: string): boolean {\n  const codeExtensions = [\n    'js', 'jsx', 'ts', 'tsx', 'py', 'java', 'c', 'cpp', 'cs',\n    'go', 'rs', 'php', 'rb', 'swift', 'kt', 'scala'\n  ];\n  return codeExtensions.includes(extension);\n}\n\n/**\n * Get package name from import path\n */\nfunction getPackageName(importPath: string): string {\n  // Relative imports don't have a package name\n  if (importPath.startsWith('.') || importPath.startsWith('/')) {\n    return 'internal';\n  }\n  \n  // Handle scoped packages (@org/pkg)\n  if (importPath.startsWith('@')) {\n    const parts = importPath.split('/');\n    if (parts.length >= 2) {\n      return `${parts[0]}/${parts[1]}`;\n    }\n  }\n  \n  // Regular packages (return first path segment)\n  return importPath.split('/')[0];\n}\n\n/**\n * Check if import is an external dependency\n */\nfunction isExternalDependency(importPath: string): boolean {\n  // Local imports start with ./ or ../\n  return !(importPath.startsWith('.') || importPath.startsWith('/'));\n}\n\n/**\n * Check if a Python module is external\n */\nfunction isExternalPythonModule(importPath: string): boolean {\n  // Common standard library modules in Python\n  const stdlibModules = [\n    'os', 'sys', 're', 'math', 'datetime', 'time', 'random',\n    'json', 'csv', 'collections', 'itertools', 'functools',\n    'pathlib', 'shutil', 'glob', 'pickle', 'urllib', 'http',\n    'logging', 'argparse', 'unittest', 'subprocess', 'threading',\n    'multiprocessing', 'typing', 'enum', 'io', 'tempfile'\n  ];\n  \n  // Consider it external if it's not in standard library\n  // and doesn't look like a relative import\n  const moduleName = importPath.split('.')[0];\n  return !stdlibModules.includes(moduleName) && !importPath.startsWith('.');\n}\n\n/**\n * Analyze project dependencies from package files\n */\nexport async function analyzeProjectDependencies(directory: string): Promise<Record<string, string>> {\n  const dependencies: Record<string, string> = {};\n  \n  try {\n    // Check for package.json\n    const packageJsonPath = path.join(directory, 'package.json');\n    if (await fileExists(packageJsonPath)) {\n      const packageJson = JSON.parse(await readTextFile(packageJsonPath));\n      \n      // Add dependencies\n      if (packageJson.dependencies) {\n        for (const [name, version] of Object.entries(packageJson.dependencies)) {\n          dependencies[name] = version as string;\n        }\n      }\n      \n      // Add dev dependencies\n      if (packageJson.devDependencies) {\n        for (const [name, version] of Object.entries(packageJson.devDependencies)) {\n          dependencies[`${name} (dev)`] = version as string;\n        }\n      }\n    }\n    \n    // Check for Python requirements.txt\n    const requirementsPath = path.join(directory, 'requirements.txt');\n    if (await fileExists(requirementsPath)) {\n      const requirements = await readTextFile(requirementsPath);\n      \n      requirements.split('\\n').forEach(line => {\n        line = line.trim();\n        if (line && !line.startsWith('#')) {\n          const [name, version] = line.split('==');\n          if (name) {\n            dependencies[name.trim()] = version ? version.trim() : 'latest';\n          }\n        }\n      });\n    }\n    \n    // Check for Gemfile for Ruby\n    const gemfilePath = path.join(directory, 'Gemfile');\n    if (await fileExists(gemfilePath)) {\n      const gemfile = await readTextFile(gemfilePath);\n      \n      const gemRegex = /^\\s*gem\\s+['\"]([^'\"]+)['\"]\\s*(?:,\\s*['\"]([^'\"]+)['\"]\\s*)?/gm;\n      let match;\n      while ((match = gemRegex.exec(gemfile)) !== null) {\n        const name = match[1];\n        const version = match[2] || 'latest';\n        if (name) {\n          dependencies[name] = version;\n        }\n      }\n    }\n  } catch (error) {\n    logger.warn('Failed to analyze project dependencies', error);\n  }\n  \n  return dependencies;\n}\n\n/**\n * Find files by content search\n */\nexport async function findFilesByContent(\n  directory: string,\n  searchTerm: string,\n  options: {\n    caseSensitive?: boolean;\n    fileExtensions?: string[];\n    maxResults?: number;\n    ignorePatterns?: string[];\n  } = {}\n): Promise<Array<{ path: string; line: number; content: string }>> {\n  const {\n    caseSensitive = false,\n    fileExtensions = [],\n    maxResults = 100,\n    ignorePatterns = DEFAULT_IGNORE_PATTERNS\n  } = options;\n  \n  const results: Array<{ path: string; line: number; content: string }> = [];\n  const flags = caseSensitive ? 'g' : 'gi';\n  const regex = new RegExp(searchTerm, flags);\n  \n  const ignoreRegexes = ignorePatterns.map(pattern => {\n    return new RegExp(\n      pattern\n        .replace(/\\./g, '\\\\.')\n        .replace(/\\*/g, '.*')\n        .replace(/\\?/g, '.')\n    );\n  });\n  \n  // Find all files (optionally filtered by extension)\n  const allFiles = await findFiles(directory, { recursive: true });\n  \n  // Filter by file extension and ignore patterns\n  const filteredFiles = allFiles.filter(file => {\n    const relativePath = path.relative(directory, file);\n    \n    // Check if file should be ignored\n    if (ignoreRegexes.some(regex => regex.test(relativePath))) {\n      return false;\n    }\n    \n    // Filter by extension if specified\n    if (fileExtensions.length > 0) {\n      const ext = path.extname(file).slice(1).toLowerCase();\n      return fileExtensions.includes(ext);\n    }\n    \n    return true;\n  });\n  \n  // Search through files for content match\n  for (const file of filteredFiles) {\n    if (results.length >= maxResults) {\n      break;\n    }\n    \n    try {\n      const content = await readTextFile(file);\n      const lines = content.split('\\n');\n      \n      for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n        if (regex.test(line)) {\n          results.push({\n            path: path.relative(directory, file),\n            line: i + 1, // 1-indexed line number\n            content: line.trim()\n          });\n          \n          if (results.length >= maxResults) {\n            break;\n          }\n        }\n      }\n    } catch (error) {\n      logger.debug(`Failed to search in file: ${file}`, error);\n    }\n  }\n  \n  return results;\n}\n\nexport default {\n  analyzeCodebase,\n  analyzeProjectDependencies,\n  findFilesByContent\n}; ","/**\n * Codebase Analysis Module\n * \n * This module provides utilities for analyzing and understanding code structure,\n * dependencies, and metrics about a codebase.\n */\n\nimport {\n  analyzeCodebase,\n  FileInfo,\n  DependencyInfo,\n  ProjectStructure,\n  analyzeProjectDependencies,\n  findFilesByContent\n} from './analyzer';\n\nexport {\n  analyzeCodebase,\n  FileInfo,\n  DependencyInfo,\n  ProjectStructure,\n  analyzeProjectDependencies,\n  findFilesByContent\n};\n\n/**\n * Analyze a codebase and return a summary of its structure\n * \n * @param directoryPath - Path to the directory to analyze\n * @param options - Analysis options\n * @returns Promise resolving to the project structure\n */\nexport async function analyzeProject(\n  directoryPath: string,\n  options: {\n    ignorePatterns?: string[];\n    maxFiles?: number;\n    maxSizePerFile?: number;\n  } = {}\n): Promise<ProjectStructure> {\n  return analyzeCodebase(directoryPath, options);\n}\n\n/**\n * Background analysis state\n */\ninterface BackgroundAnalysisState {\n  running: boolean;\n  interval: NodeJS.Timeout | null;\n  lastResults: ProjectStructure | null;\n  workingDirectory: string | null;\n}\n\n// Background analysis state\nconst backgroundAnalysis: BackgroundAnalysisState = {\n  running: false,\n  interval: null,\n  lastResults: null,\n  workingDirectory: null\n};\n\n/**\n * Initialize the codebase analysis subsystem\n * \n * @param config Configuration options for the codebase analysis\n * @returns The initialized codebase analysis system\n */\nexport function initCodebaseAnalysis(config: any = {}) {\n  const analysisConfig = config.codebase || {};\n  \n  return {\n    /**\n     * Analyze the current working directory\n     */\n    analyzeCurrentDirectory: async (options = {}) => {\n      const cwd = process.cwd();\n      return analyzeCodebase(cwd, {\n        ...analysisConfig,\n        ...options\n      });\n    },\n    \n    /**\n     * Analyze a specific directory\n     */\n    analyzeDirectory: async (directoryPath: string, options = {}) => {\n      return analyzeCodebase(directoryPath, {\n        ...analysisConfig,\n        ...options\n      });\n    },\n    \n    /**\n     * Find files by content pattern\n     */\n    findFiles: async (pattern: string, directoryPath: string = process.cwd(), options = {}) => {\n      return findFilesByContent(pattern, directoryPath, options);\n    },\n    \n    /**\n     * Analyze project dependencies\n     */\n    analyzeDependencies: async (directoryPath: string = process.cwd()) => {\n      return analyzeProjectDependencies(directoryPath);\n    },\n    \n    /**\n     * Start background analysis of the current directory\n     */\n    startBackgroundAnalysis: async (interval = 5 * 60 * 1000) => { // Default: 5 minutes\n      if (backgroundAnalysis.running) {\n        return;\n      }\n      \n      backgroundAnalysis.workingDirectory = process.cwd();\n      \n      // Check if the directory looks like a code project\n      const fs = await import('fs/promises');\n      try {\n        const files = await fs.readdir(backgroundAnalysis.workingDirectory);\n        const hasCodeFiles = files.some(file => \n          file.endsWith('.js') || file.endsWith('.ts') || file.endsWith('.py') || \n          file.endsWith('.java') || file.endsWith('.cpp') || file.endsWith('.c') ||\n          file === 'package.json' || file === 'requirements.txt' || file === 'pom.xml' ||\n          file === 'Cargo.toml' || file === 'go.mod'\n        );\n        \n        if (!hasCodeFiles) {\n          console.log('No code files detected in current directory, skipping background analysis');\n          return;\n        }\n      } catch (error: unknown) {\n        console.log('Cannot access current directory for analysis:', error instanceof Error ? error.message : String(error));\n        return;\n      }\n      \n      backgroundAnalysis.running = true;\n      \n      // Perform initial analysis\n      try {\n        const results = await analyzeCodebase(backgroundAnalysis.workingDirectory, analysisConfig);\n        backgroundAnalysis.lastResults = results;\n      } catch (err: unknown) {\n        console.log('Background analysis skipped:', err instanceof Error ? err.message : String(err));\n        return;\n      }\n      \n      // Set up interval for periodic re-analysis\n      backgroundAnalysis.interval = setInterval(async () => {\n        if (!backgroundAnalysis.running || !backgroundAnalysis.workingDirectory) {\n          return;\n        }\n        \n        try {\n          const results = await analyzeCodebase(backgroundAnalysis.workingDirectory, analysisConfig);\n          backgroundAnalysis.lastResults = results;\n        } catch (err: unknown) {\n          console.log('Background analysis error:', err instanceof Error ? err.message : String(err));\n        }\n      }, interval);\n    },\n    \n    /**\n     * Stop background analysis\n     */\n    stopBackgroundAnalysis: () => {\n      if (!backgroundAnalysis.running) {\n        return;\n      }\n      \n      if (backgroundAnalysis.interval) {\n        clearInterval(backgroundAnalysis.interval);\n        backgroundAnalysis.interval = null;\n      }\n      \n      backgroundAnalysis.running = false;\n    },\n    \n    /**\n     * Get the latest background analysis results\n     */\n    getBackgroundAnalysisResults: () => {\n      return backgroundAnalysis.lastResults;\n    }\n  };\n} ","/**\n * Command Registration\n * \n * Registers all available CLI commands with the command registry.\n */\n\nimport { commandRegistry, ArgType, CommandDef, ArgDef, CommandCategory } from './index.js';\nimport { logger } from '../utils/logger.js';\n// import { registerUpgradedCommands } from './upgraded-commands.js';\n// import { registerDoctorCommand, registerUpdateCommand, registerMigrateInstallerCommand } from './system-commands.js';\n// import { registerMCPCommand } from './mcp-commands.js';\n// import { registerAliasCommand, registerMentionCommand } from './utility-commands.js';\n// import { registerEnhancedCommands } from './enhanced-commands.js';\nimport { initAI } from '../ai/index.js';\nimport { fileExists, readTextFile } from '../fs/operations.js';\nimport { isNonEmptyString } from '../utils/validation.js';\nimport { formatErrorForDisplay } from '../errors/formatter.js';\nimport { authManager } from '../auth/index.js';\nimport { createUserError } from '../errors/formatter.js';\nimport { ErrorCategory } from '../errors/types.js';\nimport { table } from 'table';\n\n// Global AI interface\nlet aiInterface: any = null;\n\n/**\n * Get or initialize AI interface\n */\nasync function getAI(): Promise<any> {\n  if (!aiInterface) {\n    aiInterface = await initAI();\n  }\n  return aiInterface;\n}\n\n/**\n * Register all commands\n */\nexport function registerCommands(): void {\n  logger.debug('Registering commands');\n  \n  // Register core commands (avoiding AI-dependent ones for now)\n  registerExitCommand();\n  registerQuitCommand();\n  registerClearCommand();\n  registerCommandsCommand();\n  registerHelpCommand();\n  registerConfigCommand();\n  registerThemeCommand();\n  registerVerbosityCommand();\n  registerRunCommand();\n  registerResetCommand();\n  registerHistoryCommand();\n  \n  // TODO: Re-enable AI-dependent commands once punycode issue is resolved\n  // registerLoginCommand();\n  // registerLogoutCommand();\n  // registerExplainCommand();\n  // registerRefactorCommand();\n  // registerFixCommand();\n  // registerBugCommand();\n  // registerFeedbackCommand();\n  // registerEditCommand();\n  // registerGitCommand();\n  \n  // TODO: Re-enable these commands once the modules are available\n  // // Register upgraded commands with v1.0.35 features\n  // try {\n  //   registerUpgradedCommands(commandRegistry);\n  //   logger.info('Upgraded commands registered');\n  // } catch (error) {\n  //   logger.warn('Failed to register upgraded commands:', error instanceof Error ? error.message : 'Unknown error');\n  // }\n  \n  // // Register system commands\n  // try {\n  //   commandRegistry.register(registerDoctorCommand());\n  //   commandRegistry.register(registerUpdateCommand());\n  //   commandRegistry.register(registerMigrateInstallerCommand());\n  //   logger.info('System commands registered');\n  // } catch (error) {\n  //   logger.warn('Failed to register system commands:', error instanceof Error ? error.message : 'Unknown error');\n  // }\n  \n  // // Register MCP command\n  // try {\n  //   commandRegistry.register(registerMCPCommand());\n  //   logger.info('MCP command registered');\n  // } catch (error) {\n  //   logger.warn('Failed to register MCP command:', error instanceof Error ? error.message : 'Unknown error');\n  // }\n  \n  // // Register utility commands\n  // try {\n  //   commandRegistry.register(registerAliasCommand());\n  //   commandRegistry.register(registerMentionCommand());\n  //   logger.info('Utility commands registered');\n  // } catch (error) {\n  //   logger.warn('Failed to register utility commands:', error instanceof Error ? error.message : 'Unknown error');\n  // }\n  \n  // // Register enhanced commands with ripgrep (includes next-gen functionality)\n  // try {\n  //   registerEnhancedCommands(commandRegistry);\n  //   logger.info('Enhanced commands registered');\n  // } catch (error) {\n  //   logger.warn('Failed to register enhanced commands:', error instanceof Error ? error.message : 'Unknown error');\n  // }\n  \n  logger.info('Commands registered successfully');\n}\n\n/**\n * Register login command\n */\nfunction registerLoginCommand(): void {\n  const command: CommandDef = {\n    name: 'login',\n    description: 'Authenticate with Claude',\n    category: CommandCategory.AUTH,\n    handler: async (args: any) => {\n      try {\n        if (authManager.isAuthenticated()) {\n          console.log('You are already logged in.');\n          return;\n        }\n\n        const { 'api-key': apiKey, oauth } = args;\n        \n        console.log('Authenticating with Claude...');\n        \n        const apiKeyToUse = apiKey || process.env.ANTHROPIC_API_KEY;\n\n        if (apiKeyToUse) {\n          // Use API key authentication\n          const authResult = await authManager.authenticateWithApiKey();\n          if (authResult.success) {\n            console.log('Successfully logged in with API key.');\n            \n            // Display token expiration if available\n            if (authResult.token?.expiresAt) {\n              const expirationDate = new Date(authResult.token.expiresAt * 1000);\n              console.log(`Token expires on: ${expirationDate.toLocaleString()}`);\n            }\n          } else {\n            console.error(`Authentication failed: ${authResult.error || 'Unknown error'}`);\n          }\n        } else {\n          // Default to OAuth if no API key is available\n          console.log('No API key found. Proceeding with OAuth authentication...');\n          const authResult = await authManager.authenticateWithOAuth();\n          if (authResult.success) {\n            console.log('Successfully logged in with OAuth.');\n            \n            // Display token expiration if available\n            if (authResult.token?.expiresAt) {\n              const expirationDate = new Date(authResult.token.expiresAt * 1000);\n              console.log(`Token expires on: ${expirationDate.toLocaleString()}`);\n            }\n          } else {\n            console.error(`Authentication failed: ${authResult.error || 'Unknown error'}`);\n          }\n        }\n      } catch (error) {\n        console.error('Error during authentication:', formatErrorForDisplay(error));\n      }\n    },\n    args: [\n      {\n        name: 'api-key',\n        description: 'API key for Claude AI',\n        type: ArgType.STRING,\n        shortFlag: 'k'\n      },\n      {\n        name: 'oauth',\n        description: 'Use OAuth authentication',\n        type: ArgType.BOOLEAN,\n        shortFlag: 'o'\n      }\n    ]\n  };\n  \n  commandRegistry.register(command);\n}\n\n/**\n * Register logout command\n */\nfunction registerLogoutCommand(): void {\n  const command: CommandDef = {\n    name: 'logout',\n    description: 'Log out from Claude',\n    category: CommandCategory.AUTH,\n    handler: async () => {\n      try {\n        console.log('Logging out and clearing credentials...');\n        \n        // Call the auth manager's logout function\n        await authManager.logout();\n        \n        console.log('Successfully logged out. All credentials have been cleared.');\n      } catch (error) {\n        console.error('Error during logout:', formatErrorForDisplay(error));\n      }\n    }\n  };\n  \n  commandRegistry.register(command);\n}\n\n/**\n * Register ask command\n */\nfunction registerAskCommand(): void {\n  const command: CommandDef = {\n    name: 'ask',\n    description: 'Ask Claude a question',\n    category: CommandCategory.AI,\n    handler: async (args: any) => {\n      try {\n        const { question } = args;\n        \n        if (!isNonEmptyString(question)) {\n          console.error('Please provide a question to ask.');\n          return;\n        }\n        \n        console.log(`🤔 Asking: ${question}\\n`);\n        \n        // Initialize conversation history\n        const { conversationHistory } = await import('../utils/conversation-history.js');\n        try {\n          await conversationHistory.initialize();\n        } catch (error) {\n          // May already be initialized\n        }\n        \n        // Track user message\n        await conversationHistory.addMessage('user', question, {\n          command: 'ask'\n        });\n        \n        // Get AI client and send request\n        const aiClient = await getAI();\n        const result = await aiClient.query(question, {\n          maxTokens: 2048\n        });\n        \n        // Extract the response\n        const responseText = result.message.content\n          .filter((block: any) => block.type === 'text')\n          .map((block: any) => block.text)\n          .join('\\n') || 'No response received';\n        \n        console.log(responseText);\n        \n        // Track AI response\n        await conversationHistory.addMessage('assistant', responseText, {\n          command: 'ask',\n          model: result.model || 'claude-3-5-sonnet-20241022',\n          tokens: result.usage ? {\n            input: result.usage.input_tokens,\n            output: result.usage.output_tokens\n          } : undefined\n        });\n        \n        // Show usage metrics if available\n        if (result.usage) {\n          console.log(`\\n📊 Tokens: ${result.usage.input_tokens} in, ${result.usage.output_tokens} out`);\n        }\n        \n      } catch (error) {\n        const errorMessage = formatErrorForDisplay(error);\n        console.error('Error asking question:', errorMessage);\n        \n        // Track error in history\n        try {\n          const { conversationHistory } = await import('../utils/conversation-history.js');\n          await conversationHistory.addMessage('system', `Error: ${errorMessage}`, {\n            command: 'ask'\n          });\n        } catch (historyError) {\n          // Don't fail if history tracking fails\n        }\n      }\n    },\n    args: [\n      {\n        name: 'question',\n        description: 'Question to ask Claude',\n        type: ArgType.STRING,\n        position: 0,\n        required: true\n      }\n    ]\n  };\n  \n  commandRegistry.register(command);\n}\n\n/**\n * Register explain command\n */\nfunction registerExplainCommand(): void {\n  const command: CommandDef = {\n    name: 'explain',\n    description: 'Explain a code file or snippet',\n    category: CommandCategory.ASSISTANCE,\n    handler: async (args: any) => {\n      try {\n        const { file } = args;\n        \n        // Validate file path\n        if (!isNonEmptyString(file)) {\n          console.error('Please provide a file path to explain.');\n          return;\n        }\n        \n        // Check if file exists\n        if (!await fileExists(file)) {\n          console.error(`File not found: ${file}`);\n          return;\n        }\n        \n        console.log(`Explaining ${file}...\\n`);\n        \n        // Read the file\n        const fileContent = await readTextFile(file);\n        \n        // Construct the prompt using the template\n        const { PROMPT_TEMPLATES } = await import('../ai/prompts.js');\n        const explainTemplate = PROMPT_TEMPLATES.explainCode;\n        const prompt = explainTemplate.template.replace('{code}', fileContent);\n        \n        // Get AI client and send request\n        const aiClient = await getAI();\n        const result = await aiClient.query(prompt, {\n          system: explainTemplate.system,\n          maxTokens: 2048\n        });\n        \n        // Extract and print the response\n        const responseText = result.message.content\n          .filter((block: any) => block.type === 'text')\n          .map((block: any) => block.text)\n          .join('\\n') || 'No explanation received';\n        console.log(responseText);\n        \n        // Show usage metrics if available\n        if (result.usage) {\n          console.log(`\\n📊 Tokens: ${result.usage.input_tokens} in, ${result.usage.output_tokens} out`);\n        }\n      } catch (error) {\n        console.error('Error explaining code:', formatErrorForDisplay(error));\n      }\n    },\n    args: [\n      {\n        name: 'file',\n        description: 'File to explain',\n        type: ArgType.STRING,\n        position: 0,\n        required: true\n      },\n      {\n        name: 'detail',\n        description: 'Level of detail',\n        type: ArgType.STRING,\n        shortFlag: 'd',\n        choices: ['basic', 'intermediate', 'detailed'],\n        default: 'intermediate'\n      }\n    ]\n  };\n  \n  commandRegistry.register(command);\n}\n\n/**\n * Register refactor command\n */\nfunction registerRefactorCommand(): void {\n  const command: CommandDef = {\n    name: 'refactor',\n    description: 'Refactor code for better readability, performance, or structure',\n    category: CommandCategory.CODE_GENERATION,\n    handler: async (args: any) => {\n      try {\n        const { file, focus } = args;\n        \n        // Validate file path\n        if (!isNonEmptyString(file)) {\n          console.error('Please provide a file path to refactor.');\n          return;\n        }\n        \n        // Check if file exists\n        if (!await fileExists(file)) {\n          console.error(`File not found: ${file}`);\n          return;\n        }\n        \n        console.log(`Refactoring ${file} with focus on ${focus}...\\n`);\n        \n        // Read the file\n        const fileContent = await readTextFile(file);\n        \n        // Construct the prompt using the template\n        const { PROMPT_TEMPLATES } = await import('../ai/prompts.js');\n        const refactorTemplate = PROMPT_TEMPLATES.refactorCode;\n        const prompt = refactorTemplate.template\n          .replace('{code}', fileContent)\n          .replace('{focus}', focus || 'readability and maintainability')\n          .replace('{context}', 'None');\n        \n        // Get AI client and send request\n        const aiClient = await getAI();\n        const result = await aiClient.query(prompt, {\n          system: refactorTemplate.system,\n          maxTokens: 4096\n        });\n        \n        // Extract and print the response\n        const responseText = result.message.content\n          .filter((block: any) => block.type === 'text')\n          .map((block: any) => block.text)\n          .join('\\n') || 'No refactored code received';\n        console.log(responseText);\n        \n        // Show usage metrics if available\n        if (result.usage) {\n          console.log(`\\n📊 Tokens: ${result.usage.input_tokens} in, ${result.usage.output_tokens} out`);\n        }\n      } catch (error) {\n        console.error('Error refactoring code:', formatErrorForDisplay(error));\n      }\n    },\n    args: [\n      {\n        name: 'file',\n        description: 'File to refactor',\n        type: ArgType.STRING,\n        position: 0,\n        required: true\n      },\n      {\n        name: 'focus',\n        description: 'Focus of the refactoring',\n        type: ArgType.STRING,\n        shortFlag: 'f',\n        choices: ['readability', 'performance', 'simplicity', 'maintainability'],\n        default: 'readability'\n      },\n      {\n        name: 'output',\n        description: 'Output file path (defaults to stdout)',\n        type: ArgType.STRING,\n        shortFlag: 'o'\n      }\n    ]\n  };\n  \n  commandRegistry.register(command);\n}\n\n/**\n * Register fix command\n */\nfunction registerFixCommand(): void {\n  const command: CommandDef = {\n    name: 'fix',\n    description: 'Fix bugs or issues in code',\n    category: CommandCategory.ASSISTANCE,\n    handler: async (args: any) => {\n      try {\n        const { file, issue } = args;\n        \n        // Validate file path\n        if (!isNonEmptyString(file)) {\n          console.error('Please provide a file path to fix.');\n          return;\n        }\n        \n        // Check if file exists\n        if (!await fileExists(file)) {\n          console.error(`File not found: ${file}`);\n          return;\n        }\n        \n        console.log(`Fixing ${file}...\\n`);\n        \n        // Read the file\n        const fileContent = await readTextFile(file);\n        \n        // Construct the prompt using the template\n        const { PROMPT_TEMPLATES } = await import('../ai/prompts.js');\n        const debugTemplate = PROMPT_TEMPLATES.debugCode;\n        const prompt = debugTemplate.template\n          .replace('{code}', fileContent)\n          .replace('{issue}', issue || 'Identify and fix any issues')\n          .replace('{errorMessages}', 'None specified');\n        \n        // Get AI client and send request\n        const aiClient = await getAI();\n        const result = await aiClient.query(prompt, {\n          system: debugTemplate.system,\n          maxTokens: 4096\n        });\n        \n        // Extract and print the response\n        const responseText = result.message.content\n          .filter((block: any) => block.type === 'text')\n          .map((block: any) => block.text)\n          .join('\\n') || 'No fixed code received';\n        console.log(responseText);\n        \n        // Show usage metrics if available\n        if (result.usage) {\n          console.log(`\\n📊 Tokens: ${result.usage.input_tokens} in, ${result.usage.output_tokens} out`);\n        }\n      } catch (error) {\n        console.error('Error fixing code:', formatErrorForDisplay(error));\n      }\n    },\n    args: [\n      {\n        name: 'file',\n        description: 'File to fix',\n        type: ArgType.STRING,\n        position: 0,\n        required: true\n      },\n      {\n        name: 'issue',\n        description: 'Specific issue to fix (optional)',\n        type: ArgType.STRING,\n        shortFlag: 'i'\n      }\n    ]\n  };\n  \n  commandRegistry.register(command);\n}\n\n/**\n * Register generate command\n */\nfunction registerGenerateCommand(): void {\n  const command: CommandDef = {\n    name: 'generate',\n    description: 'Generate code based on a prompt',\n    category: CommandCategory.CODE_GENERATION,\n    handler: async (args: any) => {\n      try {\n        const { prompt, language, output } = args;\n        \n        // Validate prompt\n        if (!isNonEmptyString(prompt)) {\n          console.error('Please provide a prompt for code generation.');\n          return;\n        }\n        \n        console.log(`Generating ${language} code...\\n`);\n        \n        // Construct the prompt using the template\n        const { PROMPT_TEMPLATES } = await import('../ai/prompts.js');\n        const generateTemplate = PROMPT_TEMPLATES.generateCode;\n        const fullPrompt = generateTemplate.template\n          .replace('{task}', prompt)\n          .replace('{language}', language || 'JavaScript')\n          .replace('{requirements}', '- Write clean, well-documented code\\n- Follow best practices');\n        \n        // Get AI client and send request\n        const aiClient = await getAI();\n        const result = await aiClient.query(fullPrompt, {\n          system: generateTemplate.system,\n          maxTokens: 4096\n        });\n        \n        // Extract the response\n        const responseText = result.message.content\n          .filter((block: any) => block.type === 'text')\n          .map((block: any) => block.text)\n          .join('\\n') || 'No code generated';\n        \n        // Output to file or console\n        if (output) {\n          const { writeTextFile } = await import('../fs/operations.js');\n          await writeTextFile(output, responseText);\n          console.log(`Code generated and saved to: ${output}`);\n        } else {\n          console.log(responseText);\n        }\n        \n        // Show usage metrics if available\n        if (result.usage) {\n          console.log(`\\n📊 Tokens: ${result.usage.input_tokens} in, ${result.usage.output_tokens} out`);\n        }\n      } catch (error) {\n        console.error('Error generating code:', formatErrorForDisplay(error));\n      }\n    },\n    args: [\n      {\n        name: 'prompt',\n        description: 'Description of the code to generate',\n        type: ArgType.STRING,\n        position: 0,\n        required: true\n      },\n      {\n        name: 'language',\n        description: 'Programming language for the generated code',\n        type: ArgType.STRING,\n        shortFlag: 'l',\n        default: 'JavaScript'\n      },\n      {\n        name: 'output',\n        description: 'Output file path (defaults to stdout)',\n        type: ArgType.STRING,\n        shortFlag: 'o'\n      }\n    ]\n  };\n  \n  commandRegistry.register(command);\n}\n\n/**\n * Register config command\n */\nfunction registerConfigCommand(): void {\n  logger.debug('Registering config command');\n\n  const command: CommandDef = {\n    name: 'config',\n    description: 'View or set configuration values',\n    category: CommandCategory.SETTINGS,\n    async handler({ key, value }: { key?: string; value?: string }) {\n      logger.info('Executing config command');\n      \n      try {\n        const configModule = await import('../config/index.js');\n        // Load the current configuration\n        const currentConfig = await configModule.loadConfig();\n        \n        if (!key) {\n          // Display the current configuration\n          logger.info('Current configuration:');\n          console.log(JSON.stringify(currentConfig, null, 2));\n          return;\n        }\n        \n        // Handle nested keys like \"api.baseUrl\"\n        const keyPath = key.split('.');\n        let configSection: any = currentConfig;\n        \n        // Navigate to the nested config section\n        for (let i = 0; i < keyPath.length - 1; i++) {\n          configSection = configSection[keyPath[i]];\n          if (!configSection) {\n            throw new Error(`Configuration key '${key}' not found`);\n          }\n        }\n        \n        const finalKey = keyPath[keyPath.length - 1];\n        \n        if (value === undefined) {\n          // Get the value\n          const keyValue = configSection[finalKey];\n          if (keyValue === undefined) {\n            throw new Error(`Configuration key '${key}' not found`);\n          }\n          logger.info(`${key}: ${JSON.stringify(keyValue)}`);\n        } else {\n          // Set the value\n          // Parse the value if needed (convert strings to numbers/booleans)\n          let parsedValue: any = value;\n          if (value.toLowerCase() === 'true') parsedValue = true;\n          else if (value.toLowerCase() === 'false') parsedValue = false;\n          else if (!isNaN(Number(value))) parsedValue = Number(value);\n          \n          // Update the config in memory\n          configSection[finalKey] = parsedValue;\n          \n          // Save the updated config to file\n          // Since there's no direct saveConfig function, we'd need to implement\n          // this part separately to write to a config file\n          logger.info(`Configuration updated in memory: ${key} = ${JSON.stringify(parsedValue)}`);\n          logger.warn('Note: Configuration changes are only temporary for this session');\n          // In a real implementation, we would save to the config file\n        }\n      } catch (error) {\n        logger.error(`Error executing config command: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        throw error;\n      }\n    },\n    args: [\n      {\n        name: 'key',\n        description: 'Configuration key (e.g., \"api.baseUrl\")',\n        type: ArgType.STRING,\n        required: false\n      },\n      {\n        name: 'value',\n        description: 'New value to set',\n        type: ArgType.STRING,\n        required: false\n      }\n    ]\n  };\n\n  commandRegistry.register(command);\n}\n\n/**\n * Register bug command\n */\nfunction registerBugCommand(): void {\n  logger.debug('Registering bug command');\n\n  const command: CommandDef = {\n    name: 'bug',\n    description: 'Report a bug or issue',\n    category: CommandCategory.SUPPORT,\n    async handler(args: any): Promise<void> {\n      logger.info('Executing bug command');\n      \n      const description = args.description;\n      if (!isNonEmptyString(description)) {\n        throw createUserError('Bug description is required', {\n          category: ErrorCategory.VALIDATION,\n          resolution: 'Please provide a description of the bug you encountered'\n        });\n      }\n      \n      try {\n        // In a real implementation, this would send the bug report to a server\n        logger.info('Submitting bug report...');\n        \n        // Get system information\n        const os = await import('os');\n        const systemInfo = {\n          platform: os.platform(),\n          release: os.release(),\n          nodeVersion: process.version,\n          appVersion: '0.2.29', // This would come from package.json in a real implementation\n          timestamp: new Date().toISOString()\n        };\n        \n        // Get current telemetry client\n        const telemetryModule = await import('../telemetry/index.js');\n        const telemetryManager = telemetryModule.telemetry;\n        \n        telemetryManager.captureMessage(`Bug report: ${description}`, 'info');\n        \n        logger.info('Bug report submitted successfully');\n        console.log('Thank you for your bug report. Our team will investigate the issue.');\n        \n      } catch (error) {\n        logger.error(`Error submitting bug report: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        throw error;\n      }\n    },\n    args: [\n      {\n        name: 'description',\n        description: 'Description of the bug or issue',\n        type: ArgType.STRING,\n        required: true\n      }\n    ]\n  };\n\n  commandRegistry.register(command);\n}\n\n/**\n * Register feedback command\n */\nfunction registerFeedbackCommand(): void {\n  logger.debug('Registering feedback command');\n\n  const command: CommandDef = {\n    name: 'feedback',\n    description: 'Provide general feedback about Vibex',\n    category: CommandCategory.SUPPORT,\n    async handler(args: any): Promise<void> {\n      logger.info('Executing feedback command');\n      \n      const { feedback, screenshot } = args;\n      \n      let screenshotPath: string | undefined;\n      \n      // If screenshot is requested, capture it before sending feedback\n      if (screenshot) {\n        try {\n          console.log('📸 Taking screenshot...');\n          \n          const { takeScreenshot } = await import('../tools/screenshot.js');\n          const result = await takeScreenshot({\n            type: 'terminal',\n            quality: 85,\n            delay: 1000 // Give user a moment to prepare\n          });\n          \n          screenshotPath = result.filePath;\n          console.log(`Screenshot saved: ${screenshotPath}`);\n        } catch (error) {\n          console.warn(`Failed to take screenshot: ${error instanceof Error ? error.message : String(error)}`);\n          console.log('Continuing with feedback submission without screenshot...');\n        }\n      }\n      \n      if (feedback) {\n        // Get current telemetry client\n        const telemetryModule = await import('../telemetry/index.js');\n        const telemetryManager = telemetryModule.telemetry;\n        \n        if (telemetryManager) {\n          // In a real implementation, this would send the feedback to a server\n          logger.info('Submitting feedback...');\n          \n          // Get system information\n          const os = await import('os');\n          const systemInfo = {\n            platform: os.platform(),\n            release: os.release(),\n            nodeVersion: process.version,\n            appVersion: '0.2.29', // This would come from package.json in a real implementation\n            timestamp: new Date().toISOString(),\n            screenshotPath\n          };\n          \n          const feedbackMessage = `User feedback: ${feedback}${screenshotPath ? ` (Screenshot: ${screenshotPath})` : ''}`;\n          telemetryManager.captureMessage(feedbackMessage, 'info');\n          \n          logger.info('Feedback submitted successfully');\n          console.log('✅ Thank you for your feedback! We appreciate your input.');\n          \n          if (screenshotPath) {\n            console.log(`📸 Screenshot included: ${screenshotPath}`);\n          }\n        }\n      }\n    },\n    args: [\n      {\n        name: 'feedback',\n        description: 'Your feedback about Claude Code',\n        type: ArgType.STRING,\n        required: true\n      },\n      {\n        name: 'screenshot',\n        description: 'Include a screenshot with your feedback',\n        type: ArgType.BOOLEAN,\n        shortFlag: 's'\n      }\n    ]\n  };\n\n  commandRegistry.register(command);\n}\n\n/**\n * Register run command\n */\nfunction registerRunCommand(): void {\n  logger.debug('Registering run command');\n\n  const command: CommandDef = {\n    name: 'run',\n    description: 'Execute a terminal command',\n    category: CommandCategory.SYSTEM,\n    async handler(args: any): Promise<void> {\n      logger.info('Executing run command');\n      \n      const { command: commandToRun } = args;\n      if (!isNonEmptyString(commandToRun)) {\n        throw createUserError('Please provide a command to run.', {\n          category: ErrorCategory.VALIDATION,\n          resolution: 'Please provide a command to execute'\n        });\n      }\n      \n      try {\n        logger.info(`Running command: ${commandToRun}`);\n        \n        // Execute the command\n        const { exec } = await import('child_process');\n        const util = await import('util');\n        const execPromise = util.promisify(exec);\n        \n        logger.debug(`Executing: ${commandToRun}`);\n        const { stdout, stderr } = await execPromise(commandToRun);\n        \n        if (stdout) {\n          console.log(stdout);\n        }\n        \n        if (stderr) {\n          console.error(stderr);\n        }\n        \n        logger.info('Command executed successfully');\n      } catch (error) {\n        logger.error(`Error executing command: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        \n        if (error instanceof Error) {\n          console.error(`Error: ${error.message}`);\n        }\n        \n        throw error;\n      }\n    },\n    args: [\n      {\n        name: 'command',\n        description: 'The command to execute',\n        type: ArgType.STRING,\n        required: true\n      }\n    ]\n  };\n\n  commandRegistry.register(command);\n}\n\n/**\n * Register search command\n */\nfunction registerSearchCommand(): void {\n  logger.debug('Registering search command');\n\n  const command: CommandDef = {\n    name: 'search',\n    description: 'Search the codebase for a term',\n    category: CommandCategory.SYSTEM,\n    async handler(args: any): Promise<void> {\n      logger.info('Executing search command');\n      \n      const term = args.term;\n      if (!isNonEmptyString(term)) {\n        throw createUserError('Search term is required', {\n          category: ErrorCategory.VALIDATION,\n          resolution: 'Please provide a term to search for'\n        });\n      }\n      \n      try {\n        logger.info(`Searching for: ${term}`);\n        \n        // Get search directory (current directory if not specified)\n        const searchDir = args.dir || process.cwd();\n        \n        // Execute the search using ripgrep if available, otherwise fall back to simple grep\n        const { exec } = await import('child_process');\n        const util = await import('util');\n        const execPromise = util.promisify(exec);\n        \n        let searchCommand;\n        const searchPattern = term.includes(' ') ? `\"${term}\"` : term;\n        \n        try {\n          // Try to use ripgrep (rg) for better performance\n          await execPromise('rg --version');\n          \n          // Ripgrep is available, use it\n          searchCommand = `rg --color=always --line-number --heading --smart-case ${searchPattern} ${searchDir}`;\n        } catch {\n          // Fall back to grep (available on most Unix systems)\n          searchCommand = `grep -r --color=always -n \"${term}\" ${searchDir}`;\n        }\n        \n        logger.debug(`Running search command: ${searchCommand}`);\n        const { stdout, stderr } = await execPromise(searchCommand);\n        \n        if (stderr) {\n          console.error(stderr);\n        }\n        \n        if (stdout) {\n          console.log(stdout);\n        } else {\n          console.log(`No results found for '${term}'`);\n        }\n        \n        logger.info('Search completed');\n      } catch (error) {\n        logger.error(`Error searching codebase: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        \n        if (error instanceof Error) {\n          console.error(`Error: ${error.message}`);\n        }\n        \n        throw error;\n      }\n    },\n    args: [\n      {\n        name: 'term',\n        description: 'The term to search for',\n        type: ArgType.STRING,\n        position: 0,\n        required: true\n      },\n      {\n        name: 'dir',\n        description: 'Directory to search in (defaults to current directory)',\n        type: ArgType.STRING,\n        shortFlag: 'd'\n      }\n    ]\n  };\n\n  commandRegistry.register(command);\n}\n\n/**\n * Register theme command\n */\nfunction registerThemeCommand(): void {\n  logger.debug('Registering theme command');\n\n  const command: CommandDef = {\n    name: 'theme',\n    description: 'View or set the theme',\n    category: CommandCategory.SETTINGS,\n    async handler(args: any): Promise<void> {\n      logger.info('Executing theme command');\n      \n      const theme = args.name;\n      if (!isNonEmptyString(theme)) {\n        // If no theme is specified, display the current theme\n        const configModule = await import('../config/index.js');\n        const currentConfig = await configModule.loadConfig();\n        \n        console.log(`Current theme: ${currentConfig.terminal?.theme || 'default'}`);\n        return;\n      }\n      \n      // Validate the theme\n      const validThemes = ['dark', 'light', 'system'];\n      if (!validThemes.includes(theme.toLowerCase())) {\n        throw createUserError(`Invalid theme: ${theme}`, {\n          category: ErrorCategory.VALIDATION,\n          resolution: `Please choose one of: ${validThemes.join(', ')}`\n        });\n      }\n      \n      try {\n        // Update the theme in the configuration\n        const configModule = await import('../config/index.js');\n        const currentConfig = await configModule.loadConfig();\n        \n        if (currentConfig.terminal) {\n          currentConfig.terminal.theme = theme as 'dark' | 'light' | 'system';\n        }\n        \n        // await configModule.saveConfig(currentConfig);\n        \n        logger.info(`Theme updated to: ${theme}`);\n        console.log(`Theme set to: ${theme}`);\n        console.log('Note: Theme changes are only temporary for this session. Use the config command to make permanent changes.');\n        \n      } catch (error) {\n        logger.error(`Error changing theme: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        throw error;\n      }\n    },\n    args: [\n      {\n        name: 'name',\n        description: 'Theme name (dark, light, system)',\n        type: ArgType.STRING,\n        position: 0,\n        required: false\n      }\n    ]\n  };\n\n  commandRegistry.register(command);\n}\n\n/**\n * Register verbosity command\n */\nfunction registerVerbosityCommand(): void {\n  logger.debug('Registering verbosity command');\n\n  const command: CommandDef = {\n    name: 'verbosity',\n    description: 'View or set the logging verbosity level',\n    category: CommandCategory.SETTINGS,\n    async handler(args: any): Promise<void> {\n      logger.info('Executing verbosity command');\n      \n      const level = args.level;\n      \n      try {\n        // If no level is specified, display the current verbosity level\n        if (!isNonEmptyString(level)) {\n          const configModule = await import('../config/index.js');\n          const currentConfig = await configModule.loadConfig();\n          \n          console.log(`Current verbosity level: ${currentConfig.logger?.level || 'info'}`);\n          return;\n        }\n        \n        // Validate the verbosity level and map to LogLevel\n        const { LogLevel } = await import('../utils/logger.js');\n        let logLevel: any;\n        \n        switch (level.toLowerCase()) {\n          case 'debug':\n            logLevel = LogLevel.DEBUG;\n            break;\n          case 'info':\n            logLevel = LogLevel.INFO;\n            break;\n          case 'warn':\n            logLevel = LogLevel.WARN;\n            break;\n          case 'error':\n            logLevel = LogLevel.ERROR;\n            break;\n          case 'silent':\n            logLevel = LogLevel.SILENT;\n            break;\n          default:\n            console.error(`Invalid verbosity level: ${level}`);\n            return;\n        }\n        \n        // Update the verbosity level in the configuration\n        const configModule = await import('../config/index.js');\n        const currentConfig = await configModule.loadConfig();\n        \n        if (currentConfig.logger) {\n          currentConfig.logger.level = level.toLowerCase();\n        }\n        \n        // await configModule.saveConfig(currentConfig);\n        \n        logger.info(`Verbosity level updated to: ${level}`);\n        console.log(`Verbosity level set to: ${level}`);\n        \n      } catch (error) {\n        logger.error(`Error changing verbosity level: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        throw error;\n      }\n    },\n    args: [\n      {\n        name: 'level',\n        description: 'Verbosity level (debug, info, warn, error, silent)',\n        type: ArgType.STRING,\n        position: 0,\n        required: false\n      }\n    ]\n  };\n\n  commandRegistry.register(command);\n}\n\n/**\n * Register edit command\n */\nfunction registerEditCommand(): void {\n  logger.debug('Registering edit command');\n\n  const command: CommandDef = {\n    name: 'edit',\n    description: 'Edit a file with AI assistance',\n    category: CommandCategory.DEV,\n    async handler(args: any): Promise<void> {\n      logger.info('Executing edit command');\n      \n      const file = args.file;\n      if (!isNonEmptyString(file)) {\n        throw createUserError('File path is required', {\n          category: ErrorCategory.VALIDATION,\n          resolution: 'Please provide a file path to edit'\n        });\n      }\n      \n      try {\n        // Check if file exists\n        const fs = await import('fs/promises');\n        const path = await import('path');\n        \n        // Resolve the file path\n        const resolvedPath = path.resolve(process.cwd(), file);\n        \n        try {\n          // Check if file exists\n          await fs.access(resolvedPath);\n        } catch (error) {\n          // If file doesn't exist, create it with empty content\n          logger.info(`File doesn't exist, creating: ${resolvedPath}`);\n          await fs.writeFile(resolvedPath, '');\n        }\n        \n        logger.info(`Opening file for editing: ${resolvedPath}`);\n        \n        // On different platforms, open the file with different editors\n        const { platform } = await import('os');\n        const { exec } = await import('child_process');\n        const util = await import('util');\n        const execPromise = util.promisify(exec);\n        \n        let editorCommand;\n        const systemPlatform = platform();\n        \n        // Try to use the EDITOR environment variable first\n        const editor = process.env.EDITOR;\n        \n        if (editor) {\n          editorCommand = `${editor} \"${resolvedPath}\"`;\n        } else {\n          // Default editors based on platform\n          if (systemPlatform === 'win32') {\n            editorCommand = `notepad \"${resolvedPath}\"`;\n          } else if (systemPlatform === 'darwin') {\n            editorCommand = `open -a TextEdit \"${resolvedPath}\"`;\n          } else {\n            // Try nano first, fall back to vi\n            try {\n              await execPromise('which nano');\n              editorCommand = `nano \"${resolvedPath}\"`;\n            } catch {\n              editorCommand = `vi \"${resolvedPath}\"`;\n            }\n          }\n        }\n        \n        logger.debug(`Executing editor command: ${editorCommand}`);\n        console.log(`Opening ${resolvedPath} for editing...`);\n        \n        const child = exec(editorCommand);\n        \n        // Log when the editor process exits\n        child.on('exit', (code) => {\n          logger.info(`Editor process exited with code: ${code}`);\n          if (code === 0) {\n            console.log(`File saved: ${resolvedPath}`);\n          } else {\n            console.error(`Editor exited with non-zero code: ${code}`);\n          }\n        });\n        \n        // Wait for the editor to start\n        await new Promise((resolve) => setTimeout(resolve, 1000));\n        \n      } catch (error) {\n        logger.error(`Error editing file: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        throw error;\n      }\n    },\n    args: [\n      {\n        name: 'file',\n        description: 'File path to edit',\n        type: ArgType.STRING,\n        position: 0,\n        required: true\n      }\n    ]\n  };\n\n  commandRegistry.register(command);\n}\n\n/**\n * Register git command\n */\nfunction registerGitCommand(): void {\n  logger.debug('Registering git command');\n\n  const command: CommandDef = {\n    name: 'git',\n    description: 'Git operations with AI assistance',\n    category: CommandCategory.DEV,\n    async handler(args: any): Promise<void> {\n      logger.info('Executing git command');\n      \n      const operation = args.operation;\n      if (!isNonEmptyString(operation)) {\n        throw createUserError('Git operation is required', {\n          category: ErrorCategory.VALIDATION,\n          resolution: 'Please provide a git operation to perform'\n        });\n      }\n      \n      try {\n        logger.info(`Performing git operation: ${operation}`);\n        \n        // Check if git is installed\n        const { exec } = await import('child_process');\n        const util = await import('util');\n        const execPromise = util.promisify(exec);\n        \n        try {\n          await execPromise('git --version');\n        } catch (error) {\n          throw createUserError('Git is not installed or not in PATH', {\n            category: ErrorCategory.COMMAND_EXECUTION,\n            resolution: 'Please install git or add it to your PATH'\n          });\n        }\n        \n        // Validate the operation is a simple command without pipes, redirection, etc.\n        const validOpRegex = /^[a-z0-9\\-_\\s]+$/i;\n        if (!validOpRegex.test(operation)) {\n          throw createUserError('Invalid git operation', {\n            category: ErrorCategory.VALIDATION,\n            resolution: 'Please provide a simple git operation without special characters'\n          });\n        }\n        \n        // Construct and execute the git command\n        const gitCommand = `git ${operation}`;\n        logger.debug(`Executing git command: ${gitCommand}`);\n        \n        const { stdout, stderr } = await execPromise(gitCommand);\n        \n        if (stderr) {\n          console.error(stderr);\n        }\n        \n        if (stdout) {\n          console.log(stdout);\n        }\n        \n        logger.info('Git operation completed');\n      } catch (error) {\n        logger.error(`Error executing git operation: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        \n        if (error instanceof Error) {\n          console.error(`Error: ${error.message}`);\n        }\n        \n        throw error;\n      }\n    },\n    args: [\n      {\n        name: 'operation',\n        description: 'Git operation to perform',\n        type: ArgType.STRING,\n        position: 0,\n        required: true\n      }\n    ]\n  };\n\n  commandRegistry.register(command);\n}\n\n/**\n * Register exit command\n */\nfunction registerExitCommand(): void {\n  const command: CommandDef = {\n    name: 'exit',\n    description: 'Exit the application',\n    category: CommandCategory.SESSION,\n    async handler(): Promise<void> {\n      logger.info('Executing exit command');\n      console.log('Exiting Claude Code CLI...');\n      process.exit(0);\n    }\n  };\n\n  commandRegistry.register(command);\n}\n\n/**\n * Register quit command\n */\nfunction registerQuitCommand(): void {\n  const command: CommandDef = {\n    name: 'quit',\n    description: 'Exit the application',\n    category: CommandCategory.SESSION,\n    async handler(): Promise<void> {\n      logger.info('Executing quit command');\n      console.log('Exiting Claude Code CLI...');\n      process.exit(0);\n    }\n  };\n\n  commandRegistry.register(command);\n}\n\n/**\n * Register clear command\n */\nfunction registerClearCommand(): void {\n  const command: CommandDef = {\n    name: 'clear',\n    description: 'Clear the terminal screen',\n    category: CommandCategory.SESSION,\n    async handler(): Promise<void> {\n      logger.info('Executing clear command');\n      \n      // Clear the console using the appropriate method for the current platform\n      // This is the cross-platform way to clear the terminal\n      process.stdout.write('\\x1Bc');\n      \n      console.log('Display cleared.');\n    }\n  };\n\n  commandRegistry.register(command);\n}\n\n/**\n * Register reset command\n */\nfunction registerResetCommand(): void {\n  const command: CommandDef = {\n    name: 'reset',\n    description: 'Reset the conversation history',\n    category: CommandCategory.SESSION,\n    async handler(): Promise<void> {\n      logger.info('Executing reset command');\n      \n      try {\n        // Since there's no direct reset method, we'll reinitialize the AI client\n        logger.info('Reinitializing AI client to reset conversation context');\n        \n        // Re-initialize the AI client\n        await initAI();\n        \n        console.log('Conversation context has been reset.');\n        logger.info('AI client reinitialized, conversation context reset');\n      } catch (error) {\n        logger.error(`Error resetting conversation context: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        throw error;\n      }\n    }\n  };\n\n  commandRegistry.register(command);\n}\n\n/**\n * Register history command\n */\nfunction registerHistoryCommand(): void {\n  const command: CommandDef = {\n    name: 'history',\n    description: 'View conversation history',\n    category: CommandCategory.SESSION,\n    async handler(args: Record<string, any>): Promise<void> {\n      logger.info('Executing history command');\n      \n      try {\n        const { limit, search, export: exportPath, session } = args;\n        \n        // Import the conversation history manager\n        const { conversationHistory } = await import('../utils/conversation-history.js');\n        \n        // Initialize if not already done\n        try {\n          await conversationHistory.initialize();\n        } catch (error) {\n          // May already be initialized\n        }\n        \n        if (exportPath && session) {\n          // Export a specific session\n          try {\n            await conversationHistory.exportSession(session, exportPath);\n            console.log(`✅ Session exported to: ${exportPath}`);\n            return;\n          } catch (error) {\n            console.error(`Failed to export session: ${error instanceof Error ? error.message : 'Unknown error'}`);\n            return;\n          }\n        }\n        \n        if (search) {\n          // Search through conversation history\n          console.log(`🔍 Searching for: \"${search}\"\\n`);\n          \n          const results = await conversationHistory.searchMessages(search, limit || 20);\n          \n          if (results.length === 0) {\n            console.log('No messages found matching your search.');\n            return;\n          }\n          \n          console.log(`Found ${results.length} matching messages:\\n`);\n          \n          results.forEach((message, index) => {\n            const timestamp = new Date(message.timestamp).toLocaleString();\n            const role = message.role.toUpperCase().padEnd(9);\n            const preview = message.content.length > 100 \n              ? message.content.substring(0, 100) + '...'\n              : message.content;\n            \n            console.log(`${index + 1}. [${timestamp}] ${role} ${preview}`);\n            \n            if (message.metadata?.command) {\n              console.log(`   Command: /${message.metadata.command}`);\n            }\n            if (message.metadata?.file) {\n              console.log(`   File: ${message.metadata.file}`);\n            }\n            console.log('');\n          });\n          \n          return;\n        }\n        \n        if (session) {\n          // Show a specific session\n          try {\n            const sessionData = await conversationHistory.loadSession(session);\n            \n            console.log(`📖 Session: ${sessionData.title || sessionData.id}`);\n            console.log(`Started: ${new Date(sessionData.startTime).toLocaleString()}`);\n            if (sessionData.endTime) {\n              console.log(`Ended: ${new Date(sessionData.endTime).toLocaleString()}`);\n            }\n            if (sessionData.stats) {\n              console.log(`Messages: ${sessionData.stats.messageCount}, Tokens: ${sessionData.stats.totalTokens}`);\n            }\n            console.log('');\n            \n            const messagesToShow = limit ? sessionData.messages.slice(-limit) : sessionData.messages;\n            \n            messagesToShow.forEach((message, index) => {\n              const timestamp = new Date(message.timestamp).toLocaleTimeString();\n              const role = message.role.toUpperCase().padEnd(9);\n              \n              console.log(`[${timestamp}] ${role} ${message.content}`);\n              \n              if (message.metadata?.tokens) {\n                console.log(`   Tokens: ${message.metadata.tokens.input} in, ${message.metadata.tokens.output} out`);\n              }\n              console.log('');\n            });\n            \n            return;\n          } catch (error) {\n            console.error(`Session not found: ${session}`);\n            return;\n          }\n        }\n        \n        // Show recent sessions\n        const sessions = await conversationHistory.listSessions();\n        \n        if (sessions.length === 0) {\n          console.log('📜 No conversation history available.');\n          console.log('Start a conversation to begin tracking history.');\n          return;\n        }\n        \n        const sessionsToShow = sessions.slice(0, limit || 10);\n        \n        console.log(`📜 Recent Sessions (showing ${sessionsToShow.length} of ${sessions.length}):\\n`);\n        \n        sessionsToShow.forEach((session, index) => {\n          const startTime = new Date(session.startTime).toLocaleString();\n          const duration = session.endTime \n            ? Math.round((session.endTime - session.startTime) / 1000 / 60) + ' min'\n            : 'ongoing';\n          \n          console.log(`${index + 1}. ${session.title}`);\n          console.log(`   ID: ${session.id}`);\n          console.log(`   Started: ${startTime} (${duration})`);\n          console.log(`   Messages: ${session.messageCount}`);\n          console.log('');\n        });\n        \n        console.log('💡 Use the following commands to explore history:');\n        console.log('   /history --session <session-id>     View specific session');\n        console.log('   /history --search <query>           Search messages');\n        console.log('   /history --export <path> --session <id>  Export session');\n        \n      } catch (error) {\n        logger.error(`Error retrieving conversation history: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        console.error('Failed to retrieve conversation history. History tracking may be disabled.');\n      }\n    },\n    args: [\n      {\n        name: 'limit',\n        description: 'Maximum number of items to display',\n        type: ArgType.NUMBER,\n        shortFlag: 'l',\n        required: false,\n        default: 10\n      },\n      {\n        name: 'search',\n        description: 'Search for messages containing this text',\n        type: ArgType.STRING,\n        shortFlag: 's',\n        required: false\n      },\n      {\n        name: 'session',\n        description: 'Show or export a specific session by ID',\n        type: ArgType.STRING,\n        required: false\n      },\n      {\n        name: 'export',\n        description: 'Export session to file (requires --session)',\n        type: ArgType.STRING,\n        shortFlag: 'e',\n        required: false\n      }\n    ]\n  };\n\n  commandRegistry.register(command);\n}\n\n/**\n * Register commands command\n */\nfunction registerCommandsCommand(): void {\n  const command: CommandDef = {\n    name: 'commands',\n    description: 'List all available commands',\n    category: CommandCategory.HELP,\n    async handler(): Promise<void> {\n      logger.info('Executing commands command');\n      \n      try {\n        // Get all registered commands\n        const allCommands = commandRegistry.list()\n          .sort((a, b) => {\n            // Sort first by category, then by name\n            if (a.category && b.category) {\n              if (a.category !== b.category) {\n                return a.category.localeCompare(b.category);\n              }\n            } else if (a.category) {\n              return -1;\n            } else if (b.category) {\n              return 1;\n            }\n            return a.name.localeCompare(b.name);\n          });\n        \n        // Group commands by category\n        const categories = new Map<string, CommandDef[]>();\n        const uncategorizedCommands: CommandDef[] = [];\n        \n        for (const cmd of allCommands) {\n          if (cmd.category) {\n            if (!categories.has(cmd.category)) {\n              categories.set(cmd.category, []);\n            }\n            categories.get(cmd.category)!.push(cmd);\n          } else {\n            uncategorizedCommands.push(cmd);\n          }\n        }\n        \n        console.log('Available slash commands:\\n');\n        \n        // Display uncategorized commands first\n        if (uncategorizedCommands.length > 0) {\n          for (const cmd of uncategorizedCommands) {\n            console.log(`/${cmd.name.padEnd(15)} ${cmd.description}`);\n          }\n          console.log('');\n        }\n        \n        // Display categorized commands\n        for (const [category, commands] of categories.entries()) {\n          console.log(`${category}:`);\n          for (const cmd of commands) {\n            console.log(`  /${cmd.name.padEnd(13)} ${cmd.description}`);\n          }\n          console.log('');\n        }\n        \n        console.log('For more information on a specific command, use:');\n        console.log('  /help <command>');\n        \n      } catch (error) {\n        logger.error(`Error listing commands: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        throw error;\n      }\n    }\n  };\n\n  commandRegistry.register(command);\n}\n\n/**\n * Register help command\n */\nfunction registerHelpCommand(): void {\n  logger.debug('Registering help command');\n\n  const createUsage = (command: CommandDef): string => {\n    const helpText: string[] = [];\n\n    command.args?.forEach((arg: { name: string; position?: number }) => {\n      if (arg.position === undefined) {\n        helpText.push(`[--${arg.name}]`);\n      } else {\n        helpText.push(`<${arg.name}>`);\n      }\n    });\n\n    return helpText.join(' ');\n  }\n\n  const command: CommandDef = {\n    name: 'help',\n    description: 'Get help for a specific command',\n    category: CommandCategory.HELP,\n    async handler(args: Record<string, any>): Promise<void> {\n      logger.info('Executing help command');\n      \n      const commandName = args.command;\n      if (!isNonEmptyString(commandName)) {\n        throw createUserError('Command name is required', {\n          category: ErrorCategory.VALIDATION,\n          resolution: 'Please provide a command name to get help for'\n        });\n      }\n      \n      try {\n        // Get the command definition\n        const command = commandRegistry.get(commandName);\n        if (!command) {\n          throw createUserError(`Command not found: ${commandName}`, {\n            category: ErrorCategory.VALIDATION,\n            resolution: 'Please check the command name and try again'\n          });\n        }\n        \n        // Display command information\n        console.log(`Command: ${command.name}`);\n        console.log(`Description: ${command.description}`);\n        if (command.category) {\n          console.log(`Category: ${command.category}`);\n        }\n        \n        // Display command usage\n        console.log('\\nUsage:');\n        if (command.args && command.args.length > 0) {\n          console.log(`  /${command.name} ${command.args.map((arg: {name: string}) => arg.name).join(' ')}`);\n        } else {\n          console.log(`  /${command.name}`);\n        }\n        \n        // Display command arguments\n        if (command.args && command.args.length > 0) {\n          console.log('\\nArguments:');\n          for (const arg of command.args) {\n            console.log(`  ${arg.name}: ${arg.description}`);\n          }\n        }\n        \n        logger.info('Help information retrieved');\n      } catch (error) {\n        logger.error(`Error retrieving help: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        throw error;\n      }\n    },\n    args: [\n      {\n        name: 'command',\n        description: 'The command to get help for',\n        type: ArgType.STRING,\n        position: 0,\n        required: true\n      }\n    ]\n  };\n\n  commandRegistry.register(command);\n}\n\nfunction createConfigView(key: string, value: any): string {\n  if (key === 'api.key' && typeof value === 'string' && value.length > 0) {\n    return '********' + value.slice(-4);\n  }\n  if (typeof value === 'object' && value !== null) {\n    return JSON.stringify(value, (k: any, v: any) => (k === 'key' && typeof v === 'string' && v.length > 0) ? '********' + v.slice(-4) : v, 2);\n  }\n  return String(value);\n}\n\nfunction renderTable(data: any[][]) {\n  const tableConfig = {\n    border: {\n      topBody: `─`, topJoin: `┬`, topLeft: `┌`, topRight: `┐`,\n      bottomBody: `─`, bottomJoin: `┴`, bottomLeft: `└`, bottomRight: `┘`,\n      bodyLeft: `│`, bodyRight: `│`, bodyJoin: `│`,\n      headerJoin: '│'\n    },\n    drawHorizontalLine: (index: number, size: number) => {\n      return index === 0 || index === 1 || index === size;\n    }\n  };\n  console.log(table(data, tableConfig));\n} ","/**\n * File Operations Module\n * \n * Provides utilities for reading, writing, and manipulating files\n * with proper error handling and security considerations.\n */\n\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { logger } from '../utils/logger.js';\nimport { createUserError } from '../errors/formatter.js';\nimport { ErrorCategory } from '../errors/types.js';\nimport { ErrnoException } from '../utils/types.js';\n\n/**\n * Result of a file operation\n */\ninterface FileOperationResult {\n  success: boolean;\n  error?: Error;\n  path?: string;\n  content?: string;\n  created?: boolean;\n}\n\n/**\n * File Operations Manager\n */\nclass FileOperationsManager {\n  private config: any;\n  private workspacePath: string;\n\n  /**\n   * Create a new file operations manager\n   */\n  constructor(config: any) {\n    this.config = config;\n    this.workspacePath = config.workspacePath || process.cwd();\n    \n    logger.debug('File operations manager created', {\n      workspacePath: this.workspacePath\n    });\n  }\n\n  /**\n   * Initialize file operations\n   */\n  async initialize(): Promise<void> {\n    logger.info('Initializing file operations manager');\n    \n    try {\n      // Verify workspace directory exists\n      const stats = await fs.stat(this.workspacePath);\n      \n      if (!stats.isDirectory()) {\n        throw createUserError(`Workspace path is not a directory: ${this.workspacePath}`, {\n          category: ErrorCategory.FILE_SYSTEM\n        });\n      }\n      \n      logger.info('File operations manager initialized');\n    } catch (error) {\n      if ((error as ErrnoException).code === 'ENOENT') {\n        throw createUserError(`Workspace directory does not exist: ${this.workspacePath}`, {\n          category: ErrorCategory.FILE_SYSTEM,\n          resolution: 'Please provide a valid workspace path'\n        });\n      }\n      \n      logger.error('Failed to initialize file operations manager', error);\n      throw createUserError('Failed to initialize file operations', {\n        cause: error,\n        category: ErrorCategory.FILE_SYSTEM\n      });\n    }\n  }\n\n  /**\n   * Get absolute path relative to workspace\n   */\n  getAbsolutePath(relativePath: string): string {\n    // Clean up path to prevent directory traversal attacks\n    const normalizedPath = path.normalize(relativePath).replace(/^(\\.\\.(\\/|\\\\|$))+/, '');\n    return path.resolve(this.workspacePath, normalizedPath);\n  }\n\n  /**\n   * Get relative path from workspace\n   */\n  getRelativePath(absolutePath: string): string {\n    return path.relative(this.workspacePath, absolutePath);\n  }\n\n  /**\n   * Read a file\n   */\n  async readFile(filePath: string): Promise<FileOperationResult> {\n    const absolutePath = this.getAbsolutePath(filePath);\n    \n    logger.debug('Reading file', { path: filePath, absolutePath });\n    \n    try {\n      // Verify file exists and is a file\n      const stats = await fs.stat(absolutePath);\n      \n      if (!stats.isFile()) {\n        return {\n          success: false,\n          error: createUserError(`Not a file: ${filePath}`, {\n            category: ErrorCategory.FILE_SYSTEM\n          })\n        };\n      }\n      \n      // Check file size\n      const maxSizeBytes = this.config.fileOps?.maxReadSizeBytes || 10 * 1024 * 1024; // 10MB default\n      \n      if (stats.size > maxSizeBytes) {\n        return {\n          success: false,\n          error: createUserError(`File too large to read: ${filePath} (${stats.size} bytes)`, {\n            category: ErrorCategory.FILE_SYSTEM,\n            resolution: 'Try reading a smaller file or use a text editor to open this file'\n          })\n        };\n      }\n      \n      // Read file content\n      const content = await fs.readFile(absolutePath, 'utf8');\n      \n      return {\n        success: true,\n        path: filePath,\n        content\n      };\n    } catch (error) {\n      logger.error(`Error reading file: ${filePath}`, error);\n      \n      const errnoError = error as ErrnoException;\n      \n      if (errnoError.code === 'ENOENT') {\n        return {\n          success: false,\n          error: createUserError(`File not found: ${filePath}`, {\n            category: ErrorCategory.FILE_SYSTEM,\n            resolution: 'Check that the file exists and the path is correct'\n          })\n        };\n      }\n      \n      if (errnoError.code === 'EACCES') {\n        return {\n          success: false,\n          error: createUserError(`Permission denied reading file: ${filePath}`, {\n            category: ErrorCategory.FILE_SYSTEM,\n            resolution: 'Check file permissions or try running with elevated privileges'\n          })\n        };\n      }\n      \n      return {\n        success: false,\n        error: createUserError(`Failed to read file: ${filePath}`, {\n          cause: error,\n          category: ErrorCategory.FILE_SYSTEM\n        })\n      };\n    }\n  }\n\n  /**\n   * Write a file\n   */\n  async writeFile(filePath: string, content: string, options: { createDirs?: boolean } = {}): Promise<FileOperationResult> {\n    const absolutePath = this.getAbsolutePath(filePath);\n    \n    logger.debug('Writing file', { \n      path: filePath, \n      absolutePath,\n      contentLength: content.length,\n      createDirs: options.createDirs\n    });\n    \n    try {\n      // Check if file exists\n      let fileExists = false;\n      let isCreating = false;\n      \n      try {\n        const stats = await fs.stat(absolutePath);\n        fileExists = stats.isFile();\n      } catch (error) {\n        const errnoError = error as ErrnoException;\n        \n        if (errnoError.code === 'ENOENT') {\n          isCreating = true;\n          \n          // Create directories if requested\n          if (options.createDirs) {\n            const dirPath = path.dirname(absolutePath);\n            await fs.mkdir(dirPath, { recursive: true });\n          }\n        } else {\n          throw error;\n        }\n      }\n      \n      // Write file content\n      await fs.writeFile(absolutePath, content, 'utf8');\n      \n      return {\n        success: true,\n        path: filePath,\n        created: isCreating\n      };\n    } catch (error) {\n      logger.error(`Error writing file: ${filePath}`, error);\n      \n      const errnoError = error as ErrnoException;\n      \n      if (errnoError.code === 'ENOENT') {\n        return {\n          success: false,\n          error: createUserError(`Directory does not exist: ${path.dirname(filePath)}`, {\n            category: ErrorCategory.FILE_SYSTEM,\n            resolution: 'Use the createDirs option to create parent directories'\n          })\n        };\n      }\n      \n      if (errnoError.code === 'EACCES') {\n        return {\n          success: false,\n          error: createUserError(`Permission denied writing file: ${filePath}`, {\n            category: ErrorCategory.FILE_SYSTEM,\n            resolution: 'Check file permissions or try running with elevated privileges'\n          })\n        };\n      }\n      \n      return {\n        success: false,\n        error: createUserError(`Failed to write file: ${filePath}`, {\n          cause: error,\n          category: ErrorCategory.FILE_SYSTEM\n        })\n      };\n    }\n  }\n\n  /**\n   * Delete a file\n   */\n  async deleteFile(filePath: string): Promise<FileOperationResult> {\n    const absolutePath = this.getAbsolutePath(filePath);\n    \n    logger.debug('Deleting file', { path: filePath, absolutePath });\n    \n    try {\n      // Verify file exists and is a file\n      const stats = await fs.stat(absolutePath);\n      \n      if (!stats.isFile()) {\n        return {\n          success: false,\n          error: createUserError(`Not a file: ${filePath}`, {\n            category: ErrorCategory.FILE_SYSTEM\n          })\n        };\n      }\n      \n      // Delete file\n      await fs.unlink(absolutePath);\n      \n      return {\n        success: true,\n        path: filePath\n      };\n    } catch (error) {\n      logger.error(`Error deleting file: ${filePath}`, error);\n      \n      const errnoError = error as ErrnoException;\n      \n      if (errnoError.code === 'ENOENT') {\n        return {\n          success: false,\n          error: createUserError(`File not found: ${filePath}`, {\n            category: ErrorCategory.FILE_SYSTEM\n          })\n        };\n      }\n      \n      if (errnoError.code === 'EACCES') {\n        return {\n          success: false,\n          error: createUserError(`Permission denied deleting file: ${filePath}`, {\n            category: ErrorCategory.FILE_SYSTEM,\n            resolution: 'Check file permissions or try running with elevated privileges'\n          })\n        };\n      }\n      \n      return {\n        success: false,\n        error: createUserError(`Failed to delete file: ${filePath}`, {\n          cause: error,\n          category: ErrorCategory.FILE_SYSTEM\n        })\n      };\n    }\n  }\n\n  /**\n   * Check if a file exists\n   */\n  async fileExists(filePath: string): Promise<boolean> {\n    const absolutePath = this.getAbsolutePath(filePath);\n    \n    try {\n      const stats = await fs.stat(absolutePath);\n      return stats.isFile();\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Create a directory\n   */\n  async createDirectory(dirPath: string, options: { recursive?: boolean } = {}): Promise<FileOperationResult> {\n    const absolutePath = this.getAbsolutePath(dirPath);\n    \n    logger.debug('Creating directory', { \n      path: dirPath, \n      absolutePath,\n      recursive: options.recursive\n    });\n    \n    try {\n      // Create directory\n      await fs.mkdir(absolutePath, { recursive: options.recursive !== false });\n      \n      return {\n        success: true,\n        path: dirPath\n      };\n    } catch (error) {\n      logger.error(`Error creating directory: ${dirPath}`, error);\n      \n      const errnoError = error as ErrnoException;\n      \n      if (errnoError.code === 'EEXIST') {\n        return {\n          success: false,\n          error: createUserError(`Directory already exists: ${dirPath}`, {\n            category: ErrorCategory.FILE_SYSTEM\n          })\n        };\n      }\n      \n      if (errnoError.code === 'EACCES') {\n        return {\n          success: false,\n          error: createUserError(`Permission denied creating directory: ${dirPath}`, {\n            category: ErrorCategory.FILE_SYSTEM,\n            resolution: 'Check file permissions or try running with elevated privileges'\n          })\n        };\n      }\n      \n      return {\n        success: false,\n        error: createUserError(`Failed to create directory: ${dirPath}`, {\n          cause: error,\n          category: ErrorCategory.FILE_SYSTEM\n        })\n      };\n    }\n  }\n\n  /**\n   * List directory contents\n   */\n  async listDirectory(dirPath: string): Promise<FileOperationResult & { files?: string[] }> {\n    const absolutePath = this.getAbsolutePath(dirPath);\n    \n    logger.debug('Listing directory', { path: dirPath, absolutePath });\n    \n    try {\n      // Verify directory exists and is a directory\n      const stats = await fs.stat(absolutePath);\n      \n      if (!stats.isDirectory()) {\n        return {\n          success: false,\n          error: createUserError(`Not a directory: ${dirPath}`, {\n            category: ErrorCategory.FILE_SYSTEM\n          })\n        };\n      }\n      \n      // Read directory contents\n      const files = await fs.readdir(absolutePath);\n      \n      return {\n        success: true,\n        path: dirPath,\n        files\n      };\n    } catch (error) {\n      logger.error(`Error listing directory: ${dirPath}`, error);\n      \n      const errnoError = error as ErrnoException;\n      \n      if (errnoError.code === 'ENOENT') {\n        return {\n          success: false,\n          error: createUserError(`Directory not found: ${dirPath}`, {\n            category: ErrorCategory.FILE_SYSTEM\n          })\n        };\n      }\n      \n      if (errnoError.code === 'EACCES') {\n        return {\n          success: false,\n          error: createUserError(`Permission denied listing directory: ${dirPath}`, {\n            category: ErrorCategory.FILE_SYSTEM,\n            resolution: 'Check directory permissions or try running with elevated privileges'\n          })\n        };\n      }\n      \n      return {\n        success: false,\n        error: createUserError(`Failed to list directory: ${dirPath}`, {\n          cause: error,\n          category: ErrorCategory.FILE_SYSTEM\n        })\n      };\n    }\n  }\n\n  /**\n   * Generate a diff between two strings\n   */\n  generateDiff(original: string, modified: string): string {\n    // A simple line-by-line diff implementation\n    // In a real implementation, this would use a proper diff library\n    \n    const originalLines = original.split('\\n');\n    const modifiedLines = modified.split('\\n');\n    const diff: string[] = [];\n    \n    let i = 0, j = 0;\n    \n    while (i < originalLines.length || j < modifiedLines.length) {\n      if (i >= originalLines.length) {\n        // All remaining lines in modified are additions\n        diff.push(`+ ${modifiedLines[j]}`);\n        j++;\n      } else if (j >= modifiedLines.length) {\n        // All remaining lines in original are deletions\n        diff.push(`- ${originalLines[i]}`);\n        i++;\n      } else if (originalLines[i] === modifiedLines[j]) {\n        // Lines are the same\n        diff.push(`  ${originalLines[i]}`);\n        i++;\n        j++;\n      } else {\n        // Lines differ\n        // Simple approach: treat as a deletion and addition\n        // A more sophisticated diff would detect changes within lines\n        diff.push(`- ${originalLines[i]}`);\n        diff.push(`+ ${modifiedLines[j]}`);\n        i++;\n        j++;\n      }\n    }\n    \n    return diff.join('\\n');\n  }\n\n  /**\n   * Apply a patch to a file\n   */\n  async applyPatch(filePath: string, patch: string): Promise<FileOperationResult> {\n    // In a real implementation, this would parse and apply a unified diff\n    // For simplicity, we'll just write the patched content directly\n    \n    return this.writeFile(filePath, patch);\n  }\n}\n\n/**\n * Initialize the file operations system\n */\nexport async function initFileOperations(config: any): Promise<FileOperationsManager> {\n  logger.info('Initializing file operations system');\n  \n  try {\n    const fileOps = new FileOperationsManager(config);\n    await fileOps.initialize();\n    \n    logger.info('File operations system initialized successfully');\n    \n    return fileOps;\n  } catch (error) {\n    logger.error('Failed to initialize file operations system', error);\n    \n    // Create a basic file operations manager even if initialization failed\n    return new FileOperationsManager(config);\n  }\n}\n\nexport default FileOperationsManager; ","/**\n * Execution Environment Module\n * \n * Provides functionality for executing shell commands and scripts\n * in a controlled environment with proper error handling.\n */\n\nimport { exec, spawn } from 'child_process';\nimport { logger } from '../utils/logger';\nimport { createUserError } from '../errors/formatter';\nimport { ErrorCategory } from '../errors/types';\nimport { Timeout } from '../utils/types';\n\n/**\n * Result of a command execution\n */\ninterface ExecutionResult {\n  output: string;\n  exitCode: number;\n  error?: Error;\n  command: string;\n  duration: number;\n}\n\n/**\n * Command execution options\n */\ninterface ExecutionOptions {\n  cwd?: string;\n  env?: Record<string, string>;\n  timeout?: number;\n  shell?: string;\n  maxBuffer?: number;\n  captureStderr?: boolean;\n}\n\n/**\n * Background process options\n */\ninterface BackgroundProcessOptions extends ExecutionOptions {\n  onOutput?: (output: string) => void;\n  onError?: (error: string) => void;\n  onExit?: (code: number | null) => void;\n}\n\n/**\n * Background process handle\n */\ninterface BackgroundProcess {\n  pid: number;\n  kill: () => boolean;\n  isRunning: boolean;\n}\n\n/**\n * List of dangerous commands that shouldn't be executed\n */\nconst DANGEROUS_COMMANDS = [\n  /^\\s*rm\\s+(-rf?|--recursive)\\s+[\\/~]/i, // rm -rf / or similar\n  /^\\s*dd\\s+.*of=\\/dev\\/(disk|hd|sd)/i,   // dd to a device\n  /^\\s*mkfs/i,                           // Format a filesystem\n  /^\\s*:\\(\\)\\{\\s*:\\|:\\s*&\\s*\\}\\s*;/,      // Fork bomb\n  /^\\s*>(\\/dev\\/sd|\\/dev\\/hd)/,           // Overwrite disk device\n  /^\\s*sudo\\s+.*(rm|mkfs|dd|chmod|chown)/i // sudo with dangerous commands\n];\n\n/**\n * Maximum command execution time (30 seconds by default)\n */\nconst DEFAULT_TIMEOUT = 30000;\n\n/**\n * Maximum output buffer size (5MB by default)\n */\nconst DEFAULT_MAX_BUFFER = 5 * 1024 * 1024;\n\n/**\n * Execution environment manager\n */\nclass ExecutionEnvironment {\n  private config: any;\n  private backgroundProcesses: Map<number, BackgroundProcess> = new Map();\n  private executionCount: number = 0;\n  private workingDirectory: string;\n  private environmentVariables: Record<string, string>;\n\n  /**\n   * Create a new execution environment\n   */\n  constructor(config: any) {\n    this.config = config;\n    this.workingDirectory = config.execution?.cwd || process.cwd();\n    \n    // Set up environment variables\n    this.environmentVariables = {\n      ...process.env as Record<string, string>,\n      CLAUDE_CODE_VERSION: config.version || '0.2.29',\n      NODE_ENV: config.env || 'production',\n      ...(config.execution?.env || {})\n    };\n    \n    logger.debug('Execution environment created', {\n      workingDirectory: this.workingDirectory\n    });\n  }\n\n  /**\n   * Initialize the execution environment\n   */\n  async initialize(): Promise<void> {\n    logger.info('Initializing execution environment');\n    \n    try {\n      // Verify shell is available\n      const shell = this.config.execution?.shell || process.env.SHELL || 'bash';\n      \n      await this.executeCommand(`${shell} -c \"echo Shell is available\"`, {\n        timeout: 5000\n      });\n      \n      logger.info('Execution environment initialized successfully');\n    } catch (error) {\n      logger.error('Failed to initialize execution environment', error);\n      throw createUserError('Failed to initialize command execution environment', {\n        cause: error,\n        category: ErrorCategory.COMMAND_EXECUTION,\n        resolution: 'Check that your shell is properly configured'\n      });\n    }\n  }\n\n  /**\n   * Execute a shell command\n   */\n  async executeCommand(command: string, options: ExecutionOptions = {}): Promise<ExecutionResult> {\n    // Increment execution count\n    this.executionCount++;\n    \n    // Validate command for safety\n    this.validateCommand(command);\n    \n    const cwd = options.cwd || this.workingDirectory;\n    const env = { ...this.environmentVariables, ...(options.env || {}) };\n    const timeout = options.timeout || DEFAULT_TIMEOUT;\n    const maxBuffer = options.maxBuffer || DEFAULT_MAX_BUFFER;\n    const shell = options.shell || this.config.execution?.shell || process.env.SHELL || 'bash';\n    const captureStderr = options.captureStderr !== false;\n    \n    logger.debug('Executing command', {\n      command,\n      cwd,\n      shell,\n      timeout,\n      executionCount: this.executionCount\n    });\n    \n    const startTime = Date.now();\n    \n    return new Promise<ExecutionResult>((resolve, reject) => {\n      exec(command, {\n        cwd,\n        env,\n        timeout,\n        maxBuffer,\n        shell,\n        windowsHide: true,\n        encoding: 'utf8'\n      }, (error: Error | null, stdout: string, stderr: string) => {\n        const duration = Date.now() - startTime;\n        \n        // Combine stdout and stderr if requested\n        const output = captureStderr ? `${stdout}${stderr ? stderr : ''}` : stdout;\n        \n        if (error) {\n          logger.error(`Command execution failed: ${command}`, {\n            error: error.message,\n            exitCode: (error as any).code,\n            duration\n          });\n          \n          // Format the error result\n          resolve({\n            output,\n            exitCode: (error as any).code || 1,\n            error,\n            command,\n            duration\n          });\n        } else {\n          logger.debug(`Command executed successfully: ${command}`, {\n            duration,\n            outputLength: output.length\n          });\n          \n          resolve({\n            output,\n            exitCode: 0,\n            command,\n            duration\n          });\n        }\n      });\n    });\n  }\n\n  /**\n   * Execute a command in the background\n   */\n  executeCommandInBackground(command: string, options: BackgroundProcessOptions = {}): BackgroundProcess {\n    // Validate command for safety\n    this.validateCommand(command);\n    \n    const cwd = options.cwd || this.workingDirectory;\n    const env = { ...this.environmentVariables, ...(options.env || {}) };\n    const shell = options.shell || this.config.execution?.shell || process.env.SHELL || 'bash';\n    \n    logger.debug('Executing command in background', {\n      command,\n      cwd,\n      shell\n    });\n    \n    // Spawn the process\n    const childProcess = spawn(command, [], {\n      cwd,\n      env,\n      shell,\n      detached: true,\n      stdio: ['ignore', 'pipe', 'pipe']\n    });\n    \n    const pid = childProcess.pid!;\n    let isRunning = true;\n    \n    // Set up output handlers\n    if (childProcess.stdout) {\n      childProcess.stdout.on('data', (data: Buffer) => {\n        const output = data.toString('utf8');\n        logger.debug(`Background command (pid ${pid}) output:`, { output });\n        \n        if (options.onOutput) {\n          options.onOutput(output);\n        }\n      });\n    }\n    \n    if (childProcess.stderr) {\n      childProcess.stderr.on('data', (data: Buffer) => {\n        const errorOutput = data.toString('utf8');\n        logger.debug(`Background command (pid ${pid}) error:`, { errorOutput });\n        \n        if (options.onError) {\n          options.onError(errorOutput);\n        }\n      });\n    }\n    \n    // Set up exit handler\n    childProcess.on('exit', (code) => {\n      isRunning = false;\n      logger.debug(`Background command (pid ${pid}) exited with code ${code}`);\n      \n      // Remove from tracked processes\n      this.backgroundProcesses.delete(pid);\n      \n      if (options.onExit) {\n        options.onExit(code);\n      }\n    });\n    \n    // Create the process handle\n    const backgroundProcess: BackgroundProcess = {\n      pid,\n      kill: () => {\n        if (isRunning) {\n          childProcess.kill();\n          isRunning = false;\n          this.backgroundProcesses.delete(pid);\n          return true;\n        }\n        return false;\n      },\n      isRunning: true\n    };\n    \n    // Track the process\n    this.backgroundProcesses.set(pid, backgroundProcess);\n    \n    return backgroundProcess;\n  }\n\n  /**\n   * Kill all running background processes\n   */\n  killAllBackgroundProcesses(): void {\n    logger.info(`Killing ${this.backgroundProcesses.size} background processes`);\n    \n    for (const process of this.backgroundProcesses.values()) {\n      try {\n        process.kill();\n      } catch (error) {\n        logger.warn(`Failed to kill process ${process.pid}`, error);\n      }\n    }\n    \n    this.backgroundProcesses.clear();\n  }\n\n  /**\n   * Validate a command for safety\n   */\n  private validateCommand(command: string): void {\n    // Check if command is in the denied list\n    for (const pattern of DANGEROUS_COMMANDS) {\n      if (pattern.test(command)) {\n        throw createUserError(`Command execution blocked: '${command}' matches dangerous pattern`, {\n          category: ErrorCategory.COMMAND_EXECUTION,\n          resolution: 'This command is blocked for safety reasons. Please use a different command.'\n        });\n      }\n    }\n    \n    // Check if command is in allowed list (if configured)\n    if (this.config.execution?.allowedCommands && this.config.execution.allowedCommands.length > 0) {\n      const allowed = this.config.execution.allowedCommands.some(\n        (allowedPattern: string | RegExp) => {\n          if (typeof allowedPattern === 'string') {\n            return command.startsWith(allowedPattern);\n          } else {\n            return allowedPattern.test(command);\n          }\n        }\n      );\n      \n      if (!allowed) {\n        throw createUserError(`Command execution blocked: '${command}' is not in the allowed list`, {\n          category: ErrorCategory.COMMAND_EXECUTION,\n          resolution: 'This command is not allowed by your configuration.'\n        });\n      }\n    }\n  }\n\n  /**\n   * Set the working directory\n   */\n  setWorkingDirectory(directory: string): void {\n    this.workingDirectory = directory;\n    logger.debug(`Working directory set to: ${directory}`);\n  }\n\n  /**\n   * Get the working directory\n   */\n  getWorkingDirectory(): string {\n    return this.workingDirectory;\n  }\n\n  /**\n   * Set an environment variable\n   */\n  setEnvironmentVariable(name: string, value: string): void {\n    this.environmentVariables[name] = value;\n    logger.debug(`Environment variable set: ${name}=${value}`);\n  }\n\n  /**\n   * Get an environment variable\n   */\n  getEnvironmentVariable(name: string): string | undefined {\n    return this.environmentVariables[name];\n  }\n}\n\n/**\n * Initialize the execution environment\n */\nexport async function initExecutionEnvironment(config: any): Promise<ExecutionEnvironment> {\n  logger.info('Initializing execution environment');\n  \n  try {\n    const executionEnv = new ExecutionEnvironment(config);\n    await executionEnv.initialize();\n    \n    logger.info('Execution environment initialized successfully');\n    \n    return executionEnv;\n  } catch (error) {\n    logger.error('Failed to initialize execution environment', error);\n    \n    // Return a minimal execution environment even if initialization failed\n    return new ExecutionEnvironment(config);\n  }\n}\n\n// Set up cleanup on process exit\nfunction setupProcessCleanup(executionEnv: ExecutionEnvironment): void {\n  process.on('exit', () => {\n    executionEnv.killAllBackgroundProcesses();\n  });\n  \n  process.on('SIGINT', () => {\n    executionEnv.killAllBackgroundProcesses();\n    process.exit(0);\n  });\n  \n  process.on('SIGTERM', () => {\n    executionEnv.killAllBackgroundProcesses();\n    process.exit(0);\n  });\n}\n\nexport { ExecutionResult, ExecutionOptions, BackgroundProcess, BackgroundProcessOptions };\nexport default ExecutionEnvironment; ","/**\n * MCP (Model Context Protocol) Client\n * \n * Provides integration with MCP servers to extend Claude's capabilities\n * with external tools and services.\n */\n\nimport { EventEmitter } from 'events';\nimport { spawn, ChildProcess } from 'child_process';\nimport { logger } from '../utils/logger.js';\nimport { createUserError } from '../errors/formatter.js';\nimport { ErrorCategory } from '../errors/types.js';\n\nexport interface MCPServerConfig {\n  name: string;\n  command: string;\n  args?: string[];\n  env?: Record<string, string>;\n  cwd?: string;\n  timeout?: number;\n  trust?: boolean;\n  description?: string;\n}\n\nexport interface MCPTool {\n  name: string;\n  description: string;\n  input_schema: {\n    type: 'object';\n    properties: Record<string, any>;\n    required?: string[];\n  };\n}\n\nexport enum MCPServerStatus {\n  DISCONNECTED = 'disconnected',\n  CONNECTING = 'connecting',\n  CONNECTED = 'connected',\n  ERROR = 'error'\n}\n\nexport class MCPClient extends EventEmitter {\n  private servers = new Map<string, MCPServerProcess>();\n  private tools = new Map<string, MCPTool>();\n  \n  constructor() {\n    super();\n  }\n\n  async connectServer(config: MCPServerConfig): Promise<void> {\n    logger.info(`Connecting to MCP server: ${config.name}`);\n    \n    try {\n      const process = new MCPServerProcess(config);\n      await process.connect();\n      \n      this.servers.set(config.name, process);\n      \n      // Discover tools from this server\n      const tools = await process.discoverTools();\n      for (const tool of tools) {\n        const toolName = `${config.name}__${tool.name}`;\n        this.tools.set(toolName, tool);\n      }\n      \n      this.emit('server:connected', config.name);\n      logger.info(`MCP server connected: ${config.name} (${tools.length} tools)`);\n    } catch (error) {\n      logger.error(`Failed to connect MCP server ${config.name}:`, error);\n      this.emit('server:error', config.name, error);\n      throw createUserError(`Failed to connect to MCP server: ${config.name}`, {\n        cause: error,\n        category: ErrorCategory.CONNECTION\n      });\n    }\n  }\n\n  async disconnectServer(serverName: string): Promise<void> {\n    const server = this.servers.get(serverName);\n    if (server) {\n      await server.disconnect();\n      this.servers.delete(serverName);\n      \n      // Remove tools from this server\n      for (const [toolName, tool] of this.tools.entries()) {\n        if (toolName.startsWith(`${serverName}__`)) {\n          this.tools.delete(toolName);\n        }\n      }\n      \n      this.emit('server:disconnected', serverName);\n      logger.info(`MCP server disconnected: ${serverName}`);\n    }\n  }\n\n  getServerStatus(serverName: string): MCPServerStatus {\n    const server = this.servers.get(serverName);\n    return server ? server.status : MCPServerStatus.DISCONNECTED;\n  }\n\n  getAllServers(): Map<string, MCPServerProcess> {\n    return new Map(this.servers);\n  }\n\n  getAllTools(): Map<string, MCPTool> {\n    return new Map(this.tools);\n  }\n\n  async executeTool(toolName: string, parameters: any): Promise<any> {\n    const tool = this.tools.get(toolName);\n    if (!tool) {\n      throw createUserError(`MCP tool not found: ${toolName}`, {\n        category: ErrorCategory.COMMAND_NOT_FOUND\n      });\n    }\n\n    const [serverName] = toolName.split('__');\n    const server = this.servers.get(serverName);\n    if (!server || server.status !== MCPServerStatus.CONNECTED) {\n      throw createUserError(`MCP server not available: ${serverName}`, {\n        category: ErrorCategory.CONNECTION\n      });\n    }\n\n    return await server.executeToolCall(tool.name, parameters);\n  }\n\n  async disconnectAll(): Promise<void> {\n    const disconnectPromises = Array.from(this.servers.keys()).map(\n      serverName => this.disconnectServer(serverName)\n    );\n    await Promise.all(disconnectPromises);\n  }\n}\n\nclass MCPServerProcess {\n  private process: ChildProcess | null = null;\n  private _status: MCPServerStatus = MCPServerStatus.DISCONNECTED;\n  \n  constructor(private config: MCPServerConfig) {}\n\n  get status(): MCPServerStatus {\n    return this._status;\n  }\n\n  async connect(): Promise<void> {\n    this._status = MCPServerStatus.CONNECTING;\n    \n    try {\n      this.process = spawn(this.config.command, this.config.args || [], {\n        env: { ...process.env, ...this.config.env },\n        cwd: this.config.cwd || process.cwd(),\n        stdio: ['pipe', 'pipe', 'pipe']\n      });\n\n      // Set up error handling\n      this.process.on('error', (error) => {\n        logger.error(`MCP server process error (${this.config.name}):`, error);\n        this._status = MCPServerStatus.ERROR;\n      });\n\n      this.process.on('exit', (code, signal) => {\n        logger.info(`MCP server exited (${this.config.name}): code=${code}, signal=${signal}`);\n        this._status = MCPServerStatus.DISCONNECTED;\n      });\n\n      // Wait for process to be ready\n      await new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error('Connection timeout'));\n        }, this.config.timeout || 10000);\n\n        this.process!.stdout!.once('data', () => {\n          clearTimeout(timeout);\n          this._status = MCPServerStatus.CONNECTED;\n          resolve(void 0);\n        });\n      });\n    } catch (error) {\n      this._status = MCPServerStatus.ERROR;\n      throw error;\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    if (this.process) {\n      this.process.kill('SIGTERM');\n      this.process = null;\n    }\n    this._status = MCPServerStatus.DISCONNECTED;\n  }\n\n  async discoverTools(): Promise<MCPTool[]> {\n    if (!this.process || this._status !== MCPServerStatus.CONNECTED) {\n      throw new Error('Server not connected');\n    }\n\n    // Send tools discovery request via JSON-RPC\n    const request = {\n      jsonrpc: '2.0',\n      id: 1,\n      method: 'tools/list'\n    };\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Tool discovery timeout'));\n      }, this.config.timeout || 10000);\n\n      this.process!.stdout!.once('data', (data) => {\n        clearTimeout(timeout);\n        try {\n          const response = JSON.parse(data.toString());\n          if (response.result && response.result.tools) {\n            resolve(response.result.tools);\n          } else {\n            resolve([]);\n          }\n        } catch (error) {\n          reject(error);\n        }\n      });\n\n      this.process!.stdin!.write(JSON.stringify(request) + '\\n');\n    });\n  }\n\n  async executeToolCall(toolName: string, parameters: any): Promise<any> {\n    if (!this.process || this._status !== MCPServerStatus.CONNECTED) {\n      throw new Error('Server not connected');\n    }\n\n    const request = {\n      jsonrpc: '2.0',\n      id: Date.now(),\n      method: 'tools/call',\n      params: {\n        name: toolName,\n        arguments: parameters\n      }\n    };\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Tool execution timeout'));\n      }, this.config.timeout || 30000);\n\n      this.process!.stdout!.once('data', (data) => {\n        clearTimeout(timeout);\n        try {\n          const response = JSON.parse(data.toString());\n          if (response.error) {\n            reject(new Error(response.error.message));\n          } else {\n            resolve(response.result);\n          }\n        } catch (error) {\n          reject(error);\n        }\n      });\n\n      this.process!.stdin!.write(JSON.stringify(request) + '\\n');\n    });\n  }\n}\n\n// Singleton MCP client\nexport const mcpClient = new MCPClient(); ","/**\n * Main Application Initialization\n *\n * This module orchestrates the entire application startup sequence, bringing together\n * all the necessary components and services to create a fully functional CLI.\n * Key responsibilities include:\n *\n * - Loading and validating application configuration\n * - Initializing all core modules (terminal, auth, AI, etc.)\n * - Setting up the command processing loop\n * - Handling process-wide events and signals\n *\n * The `initialize` function serves as the main entry point for the application,\n * returning a fully configured application object that can be used to start\n * an interactive session or execute a single command.\n */\n\nimport { loadConfig } from './config/index.js';\nimport { initTerminal } from './terminal/index.js';\nimport { authManager } from './auth/index.js';\nimport { initAI } from './ai/index.js';\nimport { initCodebaseAnalysis } from './codebase/index.js';\nimport { registerCommands } from './commands/register.js';\nimport { initFileOperations } from './fileops/index.js';\nimport { initExecutionEnvironment } from './execution/index.js';\nimport { telemetry } from './telemetry/index.js';\nimport { logger, LogLevel } from './utils/logger.js';\nimport { formatErrorForDisplay } from './errors/formatter.js';\nimport { mcpClient } from './tools/mcp-client.js';\n\n/**\n * Application instance that holds references to all initialized subsystems\n */\nexport interface AppInstance {\n  config: any;\n  terminal: any;\n  auth: any;\n  ai: any;\n  codebase: any;\n  commands: any;\n  fileOps: any;\n  execution: any;\n  errors?: any;\n  telemetry?: any;\n}\n\n/**\n * Main application initialization\n */\nexport async function initialize(): Promise<any> {\n  try {\n    // Load configuration\n    const config = await loadConfig();\n\n    // Set up logger\n    logger.setLevel(config.logger?.level as unknown as LogLevel || LogLevel.INFO);\n\n    // Initialize modules\n    const terminal = await initTerminal(config);\n    await authManager.initialize();\n    const ai = await initAI(config);\n    const codebase = await initCodebaseAnalysis(config);\n    const fileOps = await initFileOperations(config);\n    const execution = await initExecutionEnvironment(config);\n    registerCommands();\n\n    return {\n      config,\n      terminal,\n      auth: authManager,\n      ai,\n      codebase,\n      fileOps,\n      execution,\n      telemetry\n    };\n  } catch (error) {\n    logger.error('Failed to initialize application', error as Error);\n    process.exit(1);\n  }\n}\n\n/**\n * Start interactive session with enhanced CLI interface\n */\nexport async function startInteractiveSession(app: any): Promise<void> {\n  try {\n    logger.info('Starting interactive session');\n    \n    // Collect any startup warnings\n    const startupWarnings: string[] = [];\n    \n    // Check for authentication\n    if (!authManager.isAuthenticated()) {\n      startupWarnings.push('Not authenticated. Some features may be limited. Use /login to authenticate.');\n    }\n    \n    // Initialize MCP servers if configured\n    const mcpServers = app.config.mcp?.servers || {};\n    if (Object.keys(mcpServers).length > 0) {\n      logger.info('Initializing MCP servers...');\n      for (const [name, config] of Object.entries(mcpServers)) {\n        try {\n          await mcpClient.connectServer({ name, ...config as any });\n        } catch (error) {\n          logger.warn(`Failed to connect MCP server ${name}:`, error);\n          startupWarnings.push(`MCP server '${name}' failed to connect`);\n        }\n      }\n    }\n    \n    // Display welcome and startup info\n    app.terminal.displayWelcome();\n    \n    if (startupWarnings.length > 0) {\n      app.terminal.warn('Startup warnings:');\n      startupWarnings.forEach(warning => app.terminal.warn(`  • ${warning}`));\n      app.terminal.info('');\n    }\n    \n    // Start interactive loop\n    await startInteractiveLoop(app);\n    \n    logger.info('Interactive session ended');\n  } catch (error) {\n    logger.error('Error in interactive session', error as Error);\n    throw error;\n  }\n}\n\n/**\n * Main interactive command loop\n */\nasync function startInteractiveLoop(app: any): Promise<void> {\n  const { commandRegistry } = await import('./commands/index.js');\n  \n  // Check if we're in an interactive terminal\n  if (!process.stdin.isTTY || !process.stdout.isTTY) {\n    app.terminal.warn('Non-interactive terminal detected. Exiting interactive mode.');\n    app.terminal.info('Use specific commands instead of interactive mode.');\n    return;\n  }\n  \n  while (true) {\n    try {\n      // Show prompt\n      const input = await app.terminal.prompt({\n        type: 'input',\n        name: 'command',\n        message: '❯'\n      });\n      \n      if (!input.command || input.command.trim() === '') {\n        continue;\n      }\n      \n      const trimmedInput = input.command.trim();\n      \n      // Handle exit commands\n      if (['exit', 'quit', 'q'].includes(trimmedInput.toLowerCase())) {\n        break;\n      }\n      \n      // Handle slash commands\n      if (trimmedInput.startsWith('/')) {\n        await handleSlashCommand(trimmedInput, app);\n        continue;\n      }\n      \n      // Handle AI queries\n      await handleAIQuery(trimmedInput, app);\n      \n    } catch (error) {\n      if (error instanceof Error && error.message.includes('User force closed')) {\n        break;\n      }\n      if (error instanceof Error && error.message.includes('non-interactive terminal')) {\n        app.terminal.warn('Cannot prompt in non-interactive terminal. Exiting.');\n        break;\n      }\n      app.terminal.error(`Error: ${formatErrorForDisplay(error)}`);\n    }\n  }\n  \n  // Cleanup\n  await mcpClient.disconnectAll();\n}\n\n/**\n * Handle slash commands\n */\nasync function handleSlashCommand(input: string, app: any): Promise<void> {\n  const { commandRegistry, executeCommand } = await import('./commands/index.js');\n  \n  const parts = input.slice(1).split(' ');\n  const commandName = parts[0];\n  const args = parts.slice(1);\n  \n  try {\n    await executeCommand(commandName, args);\n  } catch (error) {\n    app.terminal.error(`Command failed: ${formatErrorForDisplay(error)}`);\n  }\n}\n\n/**\n * Handle AI queries\n */\nasync function handleAIQuery(input: string, app: any): Promise<void> {\n  try {\n    app.terminal.info('Asking Claude...\\n');\n    \n    const aiClient = app.ai;\n    if (!aiClient) {\n      app.terminal.error('AI client not available. Please check your authentication.');\n      return;\n    }\n    \n    // Show spinner while processing\n    const spinner = app.terminal.spinner('Processing...');\n    \n    try {\n      const result = await aiClient.query(input);\n      spinner.succeed('Response received');\n      \n      // Extract and display response\n      const responseText = result.message.content\n        .filter((block: any) => block.type === 'text')\n        .map((block: any) => block.text)\n        .join('\\n') || 'No response received';\n      \n      app.terminal.display(responseText);\n      \n      // Show usage metrics if available\n      if (result.usage) {\n        app.terminal.info(`\\nTokens: ${result.usage.input_tokens} in, ${result.usage.output_tokens} out`);\n      }\n      \n    } catch (error) {\n      spinner.fail('Request failed');\n      throw error;\n    }\n    \n  } catch (error) {\n    app.terminal.error(`AI query failed: ${formatErrorForDisplay(error)}`);\n  }\n}\n\n/**\n * Set up process handlers\n */\nexport function setupProcessHandlers(app: any): void {\n  process.on('SIGINT', () => {\n    app.terminal.info('Caught interrupt signal. Exiting gracefully.');\n    process.exit(0);\n  });\n\n  process.on('unhandledRejection', (reason, promise) => {\n    logger.error('Unhandled Rejection', reason as Error);\n    console.error('An unexpected error occurred. Please check the logs.');\n  });\n}"],"mappings":"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","names":["chalk","rows","columns","chalk","text","url","process","path","fs","process","os","fs","fs","fs","fs","process","os","fs","promisify","process","execFile","process","process","promisify","execFile","execFileAsync","promisify","execFile","execFileAsync","execFileAsync","promisify","execFile","defaultBrowser","process","path","process","fs","defaultBrowser","EventEmitter","EventEmitter","promisify","promisify","path","fs","path","fs","regex","fs","table","exec","configModule","currentConfig","LogLevel","session","command","fs","path","fs","path","fileExists","exec","exec","childProcess","process","EventEmitter","spawn","EventEmitter","process","spawn","commandRegistry","aiClient"]}