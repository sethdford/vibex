{"version":3,"sources":["../src/commands/types.ts","../src/commands/index.ts"],"sourcesContent":["/**\n * Command System Types\n * \n * Defines the core interfaces and enums for the command system.\n */\n\n/**\n * Argument types supported by the command system\n */\nexport enum ArgType {\n  STRING = 'string',\n  NUMBER = 'number',\n  BOOLEAN = 'boolean',\n  ARRAY = 'array'\n}\n\n/**\n * Command categories for organizing help output\n */\nexport enum CommandCategory {\n  AI = 'AI',\n  AUTH = 'Auth',\n  ASSISTANCE = 'Assistance',\n  CODE_GENERATION = 'Code Generation',\n  DEV = 'Development',\n  HELP = 'Help',\n  SESSION = 'Session',\n  SETTINGS = 'Settings',\n  SUPPORT = 'Support',\n  SYSTEM = 'System',\n  UTILITY = 'Utility'\n}\n\n/**\n * Definition for a command argument\n */\nexport interface ArgDef {\n  name: string;\n  description: string;\n  type: ArgType;\n  required?: boolean;\n  position?: number;\n  shortFlag?: string;\n  default?: any;\n  choices?: string[];\n}\n\n/**\n * Definition for a command\n */\nexport interface CommandDef {\n  name: string;\n  description: string;\n  category?: CommandCategory;\n  aliases?: string[];\n  args?: ArgDef[];\n  handler: (args: any) => Promise<void>;\n}\n\n/**\n * Result of command execution\n */\nexport interface CommandResult {\n  success: boolean;\n  message?: string;\n  data?: any;\n  error?: Error;\n}\n\n/**\n * Command execution context\n */\nexport interface CommandContext {\n  config: any;\n  terminal: any;\n  ai?: any;\n  auth?: any;\n  fileOps?: any;\n  tools?: any;\n} ","/**\n * Command Management System\n *\n * This module provides the core infrastructure for defining, registering,\n * and executing commands in the CLI application. Key responsibilities include:\n *\n * - A central command registry for all available commands\n * - Command execution logic with argument parsing and validation\n * - Help generation for commands and subcommands\n * - Categorization of commands for organized help output\n *\n * The system is designed to be extensible, allowing new commands to be easily\n * added and integrated into the CLI.\n */\n\nimport { CommandDef, ArgDef, ArgType, CommandCategory } from './types.js';\nimport { logger } from '../utils/logger.js';\nimport { formatErrorForDisplay } from '../errors/formatter.js';\nimport { UserError } from '../errors/types.js';\nimport { isNonEmptyString } from '../utils/validation.js';\n\nclass CommandRegistry {\n  private commands: Map<string, CommandDef> = new Map();\n  private aliases: Map<string, string> = new Map();\n\n  register(command: CommandDef) {\n    if (this.commands.has(command.name)) {\n      logger.warn(`Command ${command.name} is already registered. Overwriting.`);\n    }\n    this.commands.set(command.name, command);\n\n    if (command.aliases) {\n      command.aliases.forEach((alias: string) => {\n        if (this.aliases.has(alias)) {\n          logger.warn(`Alias ${alias} is already registered. Overwriting.`);\n        }\n        this.aliases.set(alias, command.name);\n      });\n    }\n  }\n\n  get(name: string): CommandDef | undefined {\n    const commandName = this.aliases.get(name) || name;\n    return this.commands.get(commandName);\n  }\n\n  list(): CommandDef[] {\n    return Array.from(this.commands.values());\n  }\n\n  getCategories(): string[] {\n    const categories = new Set<string>();\n    this.commands.forEach(cmd => {\n      if (cmd.category) {\n        categories.add(cmd.category);\n      }\n    });\n    return Array.from(categories).sort();\n  }\n\n  getByCategory(category: string): CommandDef[] {\n    return this.list().filter(cmd => cmd.category === category);\n  }\n}\n\nexport const commandRegistry = new CommandRegistry();\n\nexport function generateCommandHelp(command: CommandDef): string {\n  let help = `Usage: ${command.name}`;\n  if (command.args) {\n    help += ` ${command.args.map((a: ArgDef) => `<${a.name}>`).join(' ')}`;\n  }\n  help += `\\n\\n${command.description}\\n`;\n\n  if (command.args && command.args.length > 0) {\n    help += '\\nArguments:\\n';\n    command.args.forEach((arg: ArgDef) => {\n      help += `  ${arg.name}\\t${arg.description}\\n`;\n    });\n  }\n\n  return help;\n}\n\nexport async function executeCommand(commandName: string, args: string[]): Promise<void> {\n  const command = commandRegistry.get(commandName);\n  if (!command) {\n    throw new UserError(`Unknown command: ${commandName}`);\n  }\n\n  const parsedArgs = parseArguments(args, command.args || []);\n  await command.handler(parsedArgs);\n}\n\nfunction parseArguments(args: string[], argDefs: ArgDef[]): any {\n  const parsed: { [key: string]: any } = {};\n  const positionalDefs = argDefs.filter(d => d.position !== undefined).sort((a, b) => a.position! - b.position!);\n  let positionalIndex = 0;\n\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n    if (arg.startsWith('-')) {\n      // Find the corresponding definition for a flag\n      const def = argDefs.find(d => `-${d.shortFlag}` === arg || `--${d.name}` === arg);\n      if (def) {\n        if (def.type === ArgType.BOOLEAN) {\n          parsed[def.name] = true;\n        } else {\n          // Check if next arg is a value or another flag\n          if (i + 1 < args.length && !args[i + 1].startsWith('-')) {\n            parsed[def.name] = convertArgumentType(args[i + 1], def.type);\n            i++; // consume the value\n          } else {\n             // Handle case where flag is present but value is missing, if required.\n             if(def.required) {\n                throw new UserError(`Missing value for argument: ${def.name}`);\n             }\n          }\n        }\n      } else {\n        throw new UserError(`Unknown option: ${arg}`);\n      }\n    } else {\n      // Positional arguments\n      if (positionalIndex < positionalDefs.length) {\n        const def = positionalDefs[positionalIndex];\n        parsed[def.name] = convertArgumentType(arg, def.type);\n        positionalIndex++;\n      }\n    }\n  }\n\n  // Check for required arguments that were not provided.\n  for(const def of argDefs){\n      if(def.required && parsed[def.name] === undefined){\n          throw new UserError(`Missing required argument: ${def.name}`);\n      }\n  }\n\n  return parsed;\n}\n\nfunction convertArgumentType(value: string, type: ArgType): any {\n  switch (type) {\n    case ArgType.STRING:\n      return value;\n    case ArgType.NUMBER:\n      const numberValue = parseFloat(value);\n      if (isNaN(numberValue)) {\n        throw new UserError(`Invalid number provided for argument: ${value}`);\n      }\n      return numberValue;\n    case ArgType.BOOLEAN:\n      return value.toLowerCase() === 'true' || value === '1';\n    case ArgType.ARRAY:\n      return value.split(',');\n    default:\n      return value;\n  }\n}\n\nexport {\n  CommandDef,\n  ArgDef,\n  ArgType,\n  CommandCategory,\n}; "],"mappings":"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","names":["ArgType","CommandCategory"]}