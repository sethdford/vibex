{"version":3,"sources":["../src/errors/formatter.ts"],"sourcesContent":["/**\n * Error Formatting and Presentation System\n * \n * This module provides comprehensive utilities for transforming error objects\n * into user-friendly messages and detailed developer information. Features include:\n * \n * - Human-readable error message formatting\n * - Category-specific error presentation rules\n * - Severity-based message styling\n * - Error cause chain analysis and presentation\n * - Resolution hint generation and formatting\n * - Detailed technical information extraction for debugging\n * - Terminal color formatting for error display\n * - Stack trace processing and formatting\n * - Rich error context extraction and presentation\n * - Support for both user-facing and developer-focused error formats\n * \n * The formatting system ensures that errors are presented consistently throughout\n * the application while providing appropriate detail based on the audience.\n */\n\nimport { ErrorCategory, ErrorLevel, UserError, UserErrorOptions } from './types.js';\nimport { logger } from '../utils/logger.js';\nimport { getErrorDetails, wordWrap, indent } from '../utils/formatting.js';\nimport chalk from 'chalk';\n\n/**\n * Create a user-friendly error from any error\n */\nexport function createUserError(\n  message: string,\n  options: UserErrorOptions = {}\n): UserError {\n  // Create UserError instance\n  const userError = new UserError(message, options);\n  \n  // Log the error with appropriate level\n  const level = 'warn';\n  logger[level](`User error: ${message}`, {\n    category: userError.category,\n    details: userError.details,\n    resolution: userError.resolution\n  });\n  \n  return userError;\n}\n\n/**\n * Format an error for display to the user\n */\nexport function formatErrorForDisplay(error: unknown): string {\n  if (typeof error === 'object' && error !== null) {\n    console.error('Caught object:', JSON.stringify(error, null, 2));\n  }\n  if (error instanceof UserError) {\n    return formatUserError(error);\n  }\n  \n  if (error instanceof Error) {\n    return formatSystemError(error);\n  }\n  \n  return `Unknown error: ${String(error)}`;\n}\n\n/**\n * Format a UserError for display\n */\nfunction formatUserError(error: UserError): string {\n  let message = `Error: ${error.message}`;\n  \n  // Add resolution steps if available\n  if (error.resolution) {\n    const resolutionSteps = Array.isArray(error.resolution)\n      ? error.resolution\n      : [error.resolution];\n    \n    message += '\\n\\nTo resolve this:';\n    resolutionSteps.forEach(step => {\n      message += `\\nâ€¢ ${step}`;\n    });\n  }\n  \n  // Add details if available\n  if (error.details && Object.keys(error.details).length > 0) {\n    message += '\\n\\nDetails:';\n    for (const [key, value] of Object.entries(error.details)) {\n      const formattedValue = typeof value === 'object'\n        ? JSON.stringify(value, null, 2)\n        : String(value);\n      message += `\\n${key}: ${formattedValue}`;\n    }\n  }\n  \n  return message;\n}\n\n/**\n * Format a system Error for display\n */\nfunction formatSystemError(error: Error): string {\n  let message = `System error: ${error.message}`;\n  \n  // Add stack trace for certain categories of errors\n  if (process.env.DEBUG === 'true') {\n    message += `\\n\\nStack trace:\\n${error.stack || 'No stack trace available'}`;\n  }\n  \n  return message;\n}\n\n/**\n * Convert an error to a UserError if it isn't already\n */\nexport function ensureUserError(\n  error: unknown,\n  defaultMessage: string = 'An unexpected error occurred',\n  options: UserErrorOptions = {}\n): UserError {\n  if (error instanceof UserError) {\n    return error;\n  }\n  \n  const message = error instanceof Error\n    ? error.message\n    : typeof error === 'string'\n      ? error\n      : defaultMessage;\n  \n  return createUserError(message, {\n    ...options,\n    cause: error\n  });\n}\n\n/**\n * Get a category name for an error\n */\nexport function getErrorCategoryName(category: ErrorCategory): string {\n  return ErrorCategory[category] || 'Unknown';\n}\n\n/**\n * Get an error level name\n */\nexport function getErrorLevelName(level: ErrorLevel): string {\n  return ErrorLevel[level] || 'Unknown';\n}\n\n/**\n * Get detailed information about an error\n */\nexport function getErrorDetails(error: unknown): string {\n  if (error instanceof UserError) {\n    return formatUserError(error);\n  }\n  \n  if (error instanceof Error) {\n    return formatErrorDetails(error);\n  }\n  \n  return String(error);\n} "],"mappings":";;;;;;AA6BO,SAAS,gBACd,SACA,UAA4B,CAAC,GAClB;AAEX,QAAM,YAAY,IAAI,UAAU,SAAS,OAAO;AAGhD,QAAM,QAAQ;AACd,SAAO,KAAK,EAAE,eAAe,OAAO,IAAI;AAAA,IACtC,UAAU,UAAU;AAAA,IACpB,SAAS,UAAU;AAAA,IACnB,YAAY,UAAU;AAAA,EACxB,CAAC;AAED,SAAO;AACT;AAKO,SAAS,sBAAsB,OAAwB;AAC5D,MAAI,OAAO,UAAU,YAAY,UAAU,MAAM;AAC/C,YAAQ,MAAM,kBAAkB,KAAK,UAAU,OAAO,MAAM,CAAC,CAAC;AAAA,EAChE;AACA,MAAI,iBAAiB,WAAW;AAC9B,WAAO,gBAAgB,KAAK;AAAA,EAC9B;AAEA,MAAI,iBAAiB,OAAO;AAC1B,WAAO,kBAAkB,KAAK;AAAA,EAChC;AAEA,SAAO,kBAAkB,OAAO,KAAK,CAAC;AACxC;AAKA,SAAS,gBAAgB,OAA0B;AACjD,MAAI,UAAU,UAAU,MAAM,OAAO;AAGrC,MAAI,MAAM,YAAY;AACpB,UAAM,kBAAkB,MAAM,QAAQ,MAAM,UAAU,IAClD,MAAM,aACN,CAAC,MAAM,UAAU;AAErB,eAAW;AACX,oBAAgB,QAAQ,UAAQ;AAC9B,iBAAW;AAAA,SAAO,IAAI;AAAA,IACxB,CAAC;AAAA,EACH;AAGA,MAAI,MAAM,WAAW,OAAO,KAAK,MAAM,OAAO,EAAE,SAAS,GAAG;AAC1D,eAAW;AACX,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,MAAM,OAAO,GAAG;AACxD,YAAM,iBAAiB,OAAO,UAAU,WACpC,KAAK,UAAU,OAAO,MAAM,CAAC,IAC7B,OAAO,KAAK;AAChB,iBAAW;AAAA,EAAK,GAAG,KAAK,cAAc;AAAA,IACxC;AAAA,EACF;AAEA,SAAO;AACT;AAKA,SAAS,kBAAkB,OAAsB;AAC/C,MAAI,UAAU,iBAAiB,MAAM,OAAO;AAG5C,MAAI,QAAQ,IAAI,UAAU,QAAQ;AAChC,eAAW;AAAA;AAAA;AAAA,EAAqB,MAAM,SAAS,0BAA0B;AAAA,EAC3E;AAEA,SAAO;AACT;","names":[]}