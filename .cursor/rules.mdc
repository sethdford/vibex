---
description: 
globs: 
alwaysApply: true
---
# Vibex CLI Development Rules
# Building a superior AI CLI that outperforms Gemini CLI

## 📊 GEMINI CLI ANALYSIS & COMPETITIVE BENCHMARKS

### Gemini CLI Weaknesses We Must Exploit:
- **Code Size**: 62,423 lines of TypeScript (bloated) vs our target <30,000 lines
- **Console Pollution**: 100+ console.log/warn/error statements (poor logging)
- **Memory Management**: Manual memory relaunch logic (inefficient)  
- **Architecture**: Monolithic tool registry (not modular enough)
- **Error Handling**: Generic console.error everywhere (poor UX)
- **Startup Time**: Heavy initialization with sandbox/memory checks
- **Dependencies**: 40+ npm packages (bloated dependency tree)

### Our Competitive Advantages:
- **Cleaner Architecture**: Modular, type-safe, dependency-injected
- **Better Performance**: <100ms startup vs their ~200ms
- **Superior Error Handling**: Contextual errors with recovery suggestions
- **Smaller Footprint**: <50MB memory vs their ~80MB baseline
- **Better Developer Experience**: Comprehensive TypeScript, better tooling
- **More Reliable**: Proper async/await patterns, no memory hacks

## 🎯 MISSION: Beat Gemini CLI in Every Aspect
- Performance: Faster startup, lower memory usage, better responsiveness
- Architecture: Clean, modular, testable, maintainable TypeScript
- Features: More comprehensive AI integration, better UX, superior error handling
- Code Quality: Zero technical debt, perfect type safety, comprehensive testing

## 🏗️ ARCHITECTURAL PRINCIPLES

### 1. PERFECT TYPESCRIPT
- ALWAYS use strict TypeScript settings
- NEVER use `any` type - use proper generics or unknown
- ALWAYS define interfaces for all data structures
- ALWAYS use proper error types and error handling
- ALWAYS use readonly for immutable data
- ALWAYS prefer type guards over type assertions

### 2. MODULAR ARCHITECTURE
- Follow single responsibility principle
- Use dependency injection pattern
- Implement proper separation of concerns
- Create reusable, composable modules
- Avoid circular dependencies

### 3. ERROR HANDLING EXCELLENCE
- NEVER throw generic errors
- ALWAYS use custom error types with proper context
- ALWAYS provide user-friendly error messages
- ALWAYS include recovery suggestions
- ALWAYS log errors with proper context

### 4. PERFORMANCE FIRST
- ALWAYS consider memory usage and performance impact
- Use lazy loading for non-critical modules
- Implement proper caching strategies
- Avoid blocking operations in main thread
- Profile and benchmark against Gemini CLI

## 🔍 CODE REVIEW CHECKLIST

### Before ANY commit, verify (Anti-Gemini CLI Checklist):
- [ ] All types are properly defined (no `any` - they abuse this)
- [ ] All functions have proper JSDoc comments (they have sparse docs)
- [ ] All error cases are handled (they use generic console.error)
- [ ] All async operations have proper error handling (they mix patterns)
- [ ] All imports are properly typed (they have loose imports)
- [ ] No console.log statements (they have 100+ console calls)
- [ ] All magic numbers/strings are constants (they hardcode everywhere)
- [ ] All functions are pure where possible (they have side effects)
- [ ] All side effects are properly contained (they mutate global state)
- [ ] File size <300 lines (they have 500+ line files)
- [ ] Function complexity <20 lines (they have complex functions)
- [ ] No spawn/exec without cleanup (they leak processes)
- [ ] No synchronous file operations (they use execSync)
- [ ] Performance benchmarked vs Gemini CLI (beat their metrics)

### TypeScript Specific:
- [ ] Strict mode enabled in tsconfig.json
- [ ] All function parameters and return types explicit
- [ ] All interfaces properly exported/imported
- [ ] All enums use const assertions
- [ ] All arrays use readonly where appropriate
- [ ] All objects use proper index signatures

### Architecture Specific:
- [ ] No direct file system access outside fs module
- [ ] No direct process.exit calls (use proper shutdown)
- [ ] All external dependencies properly abstracted
- [ ] All configuration properly typed and validated
- [ ] All CLI commands follow consistent patterns

## 🚀 PERFORMANCE REQUIREMENTS

### Startup Time (vs Gemini CLI):
- Target: <100ms cold start (Gemini: ~200ms)
- Lazy load all non-essential modules
- Use dynamic imports for heavy dependencies
- Cache compiled templates and configurations

### Memory Usage:
- Target: <50MB baseline (Gemini: ~80MB)
- Avoid memory leaks in long-running processes
- Properly dispose of resources
- Use streaming for large data processing

### Response Time:
- AI queries: <2s for simple requests
- File operations: <100ms for local files
- Command execution: <50ms overhead

## 🧪 TESTING STANDARDS

### Unit Tests:
- 90%+ code coverage required
- Test all error conditions
- Mock all external dependencies
- Test async operations properly

### Integration Tests:
- Test all CLI commands end-to-end
- Test all AI integrations
- Test all file operations
- Test error scenarios

### Performance Tests:
- Benchmark against Gemini CLI
- Memory leak detection
- Startup time measurement
- Response time validation

## 🎨 CODE STYLE RULES

### Naming Conventions:
- PascalCase for types, interfaces, classes
- camelCase for variables, functions, properties
- SCREAMING_SNAKE_CASE for constants
- kebab-case for file names
- Descriptive names over short names

### File Organization:
```
src/
├── types/          # All type definitions
├── interfaces/     # All interfaces
├── services/       # Business logic services
├── utils/          # Pure utility functions
├── errors/         # Custom error types
├── config/         # Configuration management
├── cli/            # CLI-specific code
└── tests/          # Test files
```

### Import Organization:
1. Node.js built-ins
2. External dependencies
3. Internal modules (absolute paths)
4. Relative imports
5. Type-only imports last

## 🔧 DEVELOPMENT WORKFLOW

### Before Starting ANY Task:
1. Read and understand the requirements
2. Plan the architecture and interfaces
3. Write types and interfaces first
4. Implement with tests
5. Benchmark against Gemini CLI
6. Document the implementation

### Code Review Process:
1. Self-review against this checklist
2. Run all tests and linting
3. Check TypeScript compilation
4. Verify performance benchmarks
5. Ensure documentation is updated

## 🚨 NEVER DO THESE (Gemini CLI Anti-Patterns):

### Code Quality (Avoid Gemini CLI Mistakes):
- NEVER use `any` type (they have poor type safety)
- NEVER ignore TypeScript errors (they have @ts-ignore everywhere)
- NEVER commit code with linting errors (their code quality is inconsistent)
- NEVER use `@ts-ignore` without detailed comment (they abuse this)
- NEVER leave TODO comments without GitHub issues (they have stale TODOs)
- NEVER use `console.log` in production code (they have 100+ console statements)
- NEVER create files >300 lines (their files are massive and hard to maintain)
- NEVER use generic variable names (they use 'data', 'result', 'item' everywhere)

### Architecture (Better Than Gemini CLI):
- NEVER create circular dependencies (they have import cycles)
- NEVER access global state directly (they have global config mutations)
- NEVER hardcode file paths or URLs (they hardcode paths in multiple places)
- NEVER skip error handling (they use generic console.error everywhere)
- NEVER create god classes/functions (their tool registry is monolithic)
- NEVER mix sync and async patterns (they inconsistently handle promises)
- NEVER use spawn/exec without proper cleanup (they leak child processes)
- NEVER create manual memory management hacks (they relaunch processes)

### Performance (Outperform Gemini CLI):
- NEVER block the event loop (they have synchronous operations)
- NEVER create memory leaks (they don't properly cleanup resources)
- NEVER use synchronous file operations in main thread (they use execSync)
- NEVER ignore resource cleanup (they don't dispose of child processes)
- NEVER create unnecessary object allocations (optimize for <50MB baseline)
- NEVER use heavy dependencies (they have 40+ packages, we need <25)
- NEVER implement features that require process relaunching (they do this for memory)
- NEVER use console.debug in hot paths (they spam debug logs)

## 🎯 GEMINI CLI BENCHMARKS TO BEAT

### Specific Performance Targets:
- **Startup Time**: <100ms (vs Gemini's ~200ms with memory checks)
- **Memory Usage**: <50MB baseline (vs Gemini's ~80MB)
- **File Operations**: <50ms for local files (vs their slower sync operations)
- **AI Response**: <2s for simple queries (match or beat their times)
- **Bundle Size**: <20MB (vs their larger bundle with 40+ deps)
- **Lines of Code**: <30,000 total (vs their 62,423 lines)

### Features to Outperform:
- **Better Error UX**: Contextual errors with recovery vs their console.error spam
- **Smarter Tool Registry**: Modular, type-safe vs their monolithic approach
- **Cleaner Logging**: Structured logging vs 100+ console statements
- **Better Memory Management**: Efficient allocation vs process relaunching
- **Superior Testing**: 90%+ coverage vs their inconsistent testing
- **Faster Build**: Optimized bundling vs their complex build system

### Architecture Advantages:
- **Dependency Injection**: Clean IoC vs their global state mutations
- **Type Safety**: Strict TypeScript vs their loose typing
- **Modular Design**: Single responsibility vs their god classes
- **Resource Management**: Proper cleanup vs their process leaks
- **Error Boundaries**: Graceful degradation vs their crash-prone code
- **Performance Monitoring**: Built-in metrics vs their manual profiling

### Code Quality Superiority:
- **File Size Limit**: Max 300 lines vs their 500+ line monsters
- **Function Complexity**: Max 20 lines vs their complex functions
- **Import Organization**: Strict ordering vs their chaotic imports
- **Documentation**: 100% JSDoc coverage vs their sparse docs
- **Testing**: Every function tested vs their partial coverage
- **Linting**: Zero warnings vs their inconsistent standards

## 📝 DOCUMENTATION REQUIREMENTS

### Every Function Must Have:
```typescript
/**
 * Brief description of what the function does
 * 
 * @param paramName - Description of parameter
 * @returns Description of return value
 * @throws {ErrorType} Description of when this error is thrown
 * 
 * @example
 * ```typescript
 * const result = await functionName(param);
 * console.log(result);
 * ```
 */
```

### Every Interface Must Have:
```typescript
/**
 * Description of the interface purpose
 * 
 * @example
 * ```typescript
 * const example: InterfaceName = {
 *   property: 'value'
 * };
 * ```
 */
interface InterfaceName {
  /** Description of property */
  property: string;
}
```

## 🔍 CONTINUOUS IMPROVEMENT

### Weekly Goals (Beat Gemini CLI):
- Reduce startup time by 10% (target: <100ms vs their ~200ms)
- Improve test coverage by 5% (target: 90%+ vs their partial coverage)
- Reduce memory usage by 5% (target: <50MB vs their ~80MB)
- Add one new feature that Gemini CLI doesn't have
- Eliminate one anti-pattern that Gemini CLI uses
- Reduce bundle size (target: <20MB vs their larger bundle)

### Monthly Reviews:
- Architecture review and refactoring (compare to Gemini CLI patterns)
- Performance benchmark comparison (startup, memory, response times)
- Technical debt assessment (eliminate Gemini CLI anti-patterns)
- Feature parity analysis with Gemini CLI (identify gaps and improvements)
- Code quality metrics (lines of code, complexity, documentation)
- Dependency audit (keep <25 packages vs their 40+)

### Competitive Analysis Rules:
- ALWAYS benchmark new features against Gemini CLI equivalent
- ALWAYS measure performance impact (startup time, memory usage)
- ALWAYS ensure our solution is more elegant and maintainable
- ALWAYS document why our approach is superior
- ALWAYS test edge cases that Gemini CLI fails on

## 🏆 SUCCESS METRICS

### Primary KPIs (vs Gemini CLI):
- **Startup Time**: <100ms (vs ~200ms) ✅ Target
- **Memory Usage**: <50MB (vs ~80MB) ✅ Target  
- **Lines of Code**: <30,000 (vs 62,423) ✅ Target
- **Bundle Size**: <20MB (vs larger bundle) ✅ Target
- **Test Coverage**: 90%+ (vs partial) ✅ Target
- **Dependencies**: <25 (vs 40+) ✅ Target
- **Console Statements**: 0 (vs 100+) ✅ Target
- **Max File Size**: 300 lines (vs 500+) ✅ Target

Remember: We're not just building a CLI, we're building THE BEST AI CLI that makes Gemini CLI obsolete. Every line of code should reflect this ambition. We have analyzed their 62,423 lines of code and identified their weaknesses - now we exploit them with superior architecture, performance, and code quality. 